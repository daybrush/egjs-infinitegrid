{"version":3,"file":"infinitegrid.js","sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 3fa407e50ffb65e52bf7","webpack:///./src/consts.js","webpack:///./src/utils.js","webpack:///./src/browser.js","webpack:///./src/DOMRenderer.js","webpack:///./src/layouts/FrameLayout.js","webpack:///./src/index.js","webpack:///./src/InfiniteGrid.js","webpack:///external {\"commonjs\":\"@egjs/component\",\"commonjs2\":\"@egjs/component\",\"amd\":\"@egjs/component\",\"root\":[\"eg\",\"Component\"]}","webpack:///./src/ItemManager.js","webpack:///./src/ImageLoaded.js","webpack:///./src/Watcher.js","webpack:///./src/layouts/GridLayout.js","webpack:///./src/layouts/SquareLayout.js","webpack:///./src/layouts/PackingLayout.js","webpack:///./src/layouts/lib/BoxModel.js","webpack:///./src/layouts/JustifiedLayout.js","webpack:///./src/layouts/lib/dijkstra.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@egjs/component\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"@egjs/component\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"InfiniteGrid\"] = factory(require(\"@egjs/component\"));\n\telse\n\t\troot[\"eg\"] = root[\"eg\"] || {}, root[\"eg\"][\"InfiniteGrid\"] = factory(root[\"eg\"][\"Component\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_7__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 3fa407e50ffb65e52bf7","\"use strict\";\n\nexports.__esModule = true;\nexports.ALIGN = exports.DEFAULT_OPTIONS = exports.GROUPKEY_ATT = exports.DUMMY_POSITION = exports.SINGLE = exports.MULTI = exports.NO_TRUSTED = exports.TRUSTED = exports.NO_CACHE = exports.CACHE = exports.HORIZONTAL = exports.VERTICAL = exports.PREPEND = exports.APPEND = exports.CONTAINER_CLASSNAME = exports.RETRY = exports.IS_ANDROID2 = exports.IS_IOS = exports.IS_IE = exports.SUPPORT_PASSIVE = exports.SUPPORT_ADDEVENTLISTENER = exports.SUPPORT_COMPUTEDSTYLE = undefined;\n\nvar _browser = require(\"./browser\");\n\nvar ua = _browser.window.navigator.userAgent;\n\nvar SUPPORT_COMPUTEDSTYLE = exports.SUPPORT_COMPUTEDSTYLE = !!(\"getComputedStyle\" in _browser.window);\nvar SUPPORT_ADDEVENTLISTENER = exports.SUPPORT_ADDEVENTLISTENER = !!(\"addEventListener\" in document);\nvar SUPPORT_PASSIVE = exports.SUPPORT_PASSIVE = function () {\n\tvar supportsPassiveOption = false;\n\n\ttry {\n\t\tif (SUPPORT_ADDEVENTLISTENER && Object.defineProperty) {\n\t\t\tdocument.addEventListener(\"test\", null, Object.defineProperty({}, \"passive\", {\n\t\t\t\tget: function get() {\n\t\t\t\t\tsupportsPassiveOption = true;\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t} catch (e) {}\n\treturn supportsPassiveOption;\n}();\n\nvar IS_IE = exports.IS_IE = /MSIE|Trident|Windows Phone|Edge/.test(ua);\nvar IS_IOS = exports.IS_IOS = /iPhone|iPad/.test(ua);\nvar IS_ANDROID2 = exports.IS_ANDROID2 = /Android 2\\./.test(ua);\nvar RETRY = exports.RETRY = 3;\nvar CONTAINER_CLASSNAME = exports.CONTAINER_CLASSNAME = \"_eg-infinitegrid-container_\";\n\nvar APPEND = exports.APPEND = true;\nvar PREPEND = exports.PREPEND = false;\nvar VERTICAL = exports.VERTICAL = \"vertical\";\nvar HORIZONTAL = exports.HORIZONTAL = \"horizontal\";\nvar CACHE = exports.CACHE = true;\nvar NO_CACHE = exports.NO_CACHE = false;\nvar TRUSTED = exports.TRUSTED = true;\nvar NO_TRUSTED = exports.NO_TRUSTED = false;\nvar MULTI = exports.MULTI = true;\nvar SINGLE = exports.SINGLE = false;\nvar DUMMY_POSITION = exports.DUMMY_POSITION = -100000;\nvar GROUPKEY_ATT = exports.GROUPKEY_ATT = \"data-groupkey\";\n\nvar DEFAULT_OPTIONS = exports.DEFAULT_OPTIONS = {\n\tdirection: VERTICAL,\n\tmargin: 0\n};\n\nvar ALIGN = exports.ALIGN = {\n\tSTART: \"start\",\n\tCENTER: \"center\",\n\tEND: \"end\",\n\tJUSTIFY: \"justify\"\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/consts.js\n// module id = 0\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\nexports.STYLE = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.toArray = toArray;\nexports.fill = fill;\nexports.$ = $;\nexports.addEvent = addEvent;\nexports.removeEvent = removeEvent;\nexports.scroll = scroll;\nexports.scrollTo = scrollTo;\nexports.scrollBy = scrollBy;\nexports.innerWidth = innerWidth;\nexports.innerHeight = innerHeight;\nexports.getStyleNames = getStyleNames;\nexports.assignOptions = assignOptions;\nexports.toZeroArray = toZeroArray;\n\nvar _browser = require(\"./browser\");\n\nvar _consts = require(\"./consts\");\n\nfunction toArray(nodes) {\n\t// SCRIPT5014 in IE8\n\tvar array = [];\n\n\tif (nodes) {\n\t\tfor (var i = 0, len = nodes.length; i < len; i++) {\n\t\t\tarray.push(nodes[i]);\n\t\t}\n\t}\n\treturn array;\n}\nfunction fill(length, value) {\n\tvar array = (typeof length === \"undefined\" ? \"undefined\" : _typeof(length)) === \"object\" ? length : new Array(length);\n\tvar len = array.length;\n\n\tfor (var i = len - 1; i >= 0; --i) {\n\t\tarray[i] = value;\n\t}\n\treturn array;\n}\n/**\n * Select or create element\n * @param {String|HTMLElement|jQuery} param\n *  when string given is as HTML tag, then create element\n *  otherwise it returns selected elements\n * @param {Boolean} multi\n * @returns {HTMLElement}\n */\nfunction $(param) {\n\tvar multi = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n\tvar el = void 0;\n\n\tif (typeof param === \"string\") {\n\t\t// String (HTML, Selector)\n\t\t// check if string is HTML tag format\n\t\tvar match = param.match(/^<([a-z]+)\\s*([^>]*)>/);\n\n\t\t// creating element\n\t\tif (match) {\n\t\t\t// HTML\n\t\t\tvar dummy = _browser.document.createElement(\"div\");\n\n\t\t\tdummy.innerHTML = param;\n\t\t\tel = toArray(dummy.childNodes);\n\t\t} else {\n\t\t\t// Selector\n\t\t\tel = toArray(_browser.document.querySelectorAll(param));\n\t\t}\n\t\tif (!multi) {\n\t\t\tel = el.length >= 1 ? el[0] : undefined;\n\t\t}\n\t} else if (param === _browser.window) {\n\t\t// window\n\t\tel = param;\n\t} else if (param.nodeName && (param.nodeType === 1 || param.nodeType === 9)) {\n\t\t// HTMLElement, Document\n\t\tel = param;\n\t} else if (\"jQuery\" in _browser.window && param instanceof jQuery || param.constructor.prototype.jquery) {\n\t\t// jQuery\n\t\tel = multi ? param.toArray() : param.get(0);\n\t} else if (Array.isArray(param)) {\n\t\tel = param.map(function (v) {\n\t\t\treturn $(v);\n\t\t});\n\t\tif (!multi) {\n\t\t\tel = el.length >= 1 ? el[0] : undefined;\n\t\t}\n\t}\n\treturn el;\n}\nfunction addEvent(element, type, handler, eventListenerOptions) {\n\tif (_consts.SUPPORT_ADDEVENTLISTENER) {\n\t\tvar options = eventListenerOptions || false;\n\n\t\tif ((typeof eventListenerOptions === \"undefined\" ? \"undefined\" : _typeof(eventListenerOptions)) === \"object\") {\n\t\t\toptions = _consts.SUPPORT_PASSIVE ? eventListenerOptions : false;\n\t\t}\n\t\telement.addEventListener(type, handler, options);\n\t} else if (element.attachEvent) {\n\t\telement.attachEvent(\"on\" + type, handler);\n\t} else {\n\t\telement[\"on\" + type] = handler;\n\t}\n}\nfunction removeEvent(element, type, handler) {\n\tif (element.removeEventListener) {\n\t\telement.removeEventListener(type, handler, false);\n\t} else if (element.detachEvent) {\n\t\telement.detachEvent(\"on\" + type, handler);\n\t} else {\n\t\telement[\"on\" + type] = null;\n\t}\n}\nfunction scroll(el, isVertical) {\n\tvar prop = \"scroll\" + (isVertical ? \"Top\" : \"Left\");\n\n\tif (el === _browser.window) {\n\t\treturn _browser.document.body[prop] || _browser.document.documentElement[prop];\n\t} else {\n\t\treturn el[prop];\n\t}\n}\nfunction scrollTo(el, x, y) {\n\tif (el === _browser.window) {\n\t\tel.scroll(x, y);\n\t} else {\n\t\tel.scrollLeft = x;\n\t\tel.scrollTop = y;\n\t}\n}\nfunction scrollBy(el, x, y) {\n\tif (el === _browser.window) {\n\t\tel.scrollBy(x, y);\n\t} else {\n\t\tel.scrollLeft += x;\n\t\tel.scrollTop += y;\n\t}\n}\nfunction _getSize(el, name) {\n\tif (el === _browser.window) {\n\t\t// WINDOW\n\t\treturn el.document.documentElement[\"client\" + name];\n\t} else if (el.nodeType === 9) {\n\t\t// DOCUMENT_NODE\n\t\tvar doc = el.documentElement;\n\n\t\treturn Math.max(el.body[\"scroll\" + name], doc[\"scroll\" + name], el.body[\"offset\" + name], doc[\"offset\" + name], doc[\"client\" + name]);\n\t} else {\n\t\t// NODE\n\t\tvar style = _consts.SUPPORT_COMPUTEDSTYLE ? _browser.window.getComputedStyle(el) : el.currentStyle;\n\t\tvar value = style[name.toLowerCase()];\n\n\t\treturn parseFloat(/auto|%/.test(value) ? el[\"offset\" + name] : style[name.toLowerCase()]);\n\t}\n}\nfunction innerWidth(el) {\n\treturn _getSize(el, \"Width\");\n}\nfunction innerHeight(el) {\n\treturn _getSize(el, \"Height\");\n}\n\nvar STYLE = exports.STYLE = {\n\tvertical: {\n\t\tpos1: \"top\",\n\t\tendPos1: \"bottom\",\n\t\tsize1: \"height\",\n\t\tpos2: \"left\",\n\t\tendPos2: \"right\",\n\t\tsize2: \"width\"\n\t},\n\thorizontal: {\n\t\tpos1: \"left\",\n\t\tendPos1: \"right\",\n\t\tsize1: \"width\",\n\t\tpos2: \"top\",\n\t\tendPos2: \"bottom\",\n\t\tsize2: \"height\"\n\t}\n};\n\nfunction getStyleNames(direction) {\n\tvar style = STYLE[direction in STYLE ? direction : _consts.VERTICAL];\n\n\treturn style;\n}\n\nfunction assignOptions(defaultOptions, options) {\n\treturn _extends({}, _consts.DEFAULT_OPTIONS, defaultOptions, options);\n}\n\nfunction toZeroArray(outline) {\n\tif (!outline || !outline.length) {\n\t\treturn [0];\n\t}\n\treturn outline;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/utils.js\n// module id = 1\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\n/* eslint-disable no-new-func, no-nested-ternary */\nvar win = typeof window !== \"undefined\" && window.Math === Math ? window : typeof self !== \"undefined\" && self.Math === Math ? self : Function(\"return this\")();\n/* eslint-enable no-new-func, no-nested-ternary */\n\nexports.window = win;\nvar document = exports.document = win.document;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/browser.js\n// module id = 2\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _consts = require(\"./consts\");\n\nvar _utils = require(\"./utils\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DOMRenderer = function () {\n\tDOMRenderer.renderItem = function renderItem(item, styles) {\n\t\tif (item.el) {\n\t\t\tvar elStyle = item.el.style;\n\n\t\t\t// for debugging\n\t\t\titem.el.setAttribute(_consts.GROUPKEY_ATT, item.groupKey);\n\t\t\telStyle.position = \"absolute\";\n\t\t\t[\"left\", \"top\", \"width\", \"height\"].forEach(function (p) {\n\t\t\t\tp in styles && (elStyle[p] = styles[p] + \"px\");\n\t\t\t});\n\t\t}\n\t};\n\n\tDOMRenderer.renderItems = function renderItems(items) {\n\t\titems.forEach(function (item) {\n\t\t\tDOMRenderer.renderItem(item, item.rect);\n\t\t});\n\t};\n\n\tDOMRenderer.removeItems = function removeItems(items) {\n\t\titems.forEach(function (item) {\n\t\t\tif (item.el) {\n\t\t\t\tDOMRenderer.removeElement(item.el);\n\t\t\t\titem.el = null;\n\t\t\t}\n\t\t});\n\t};\n\n\tDOMRenderer.removeElement = function removeElement(element) {\n\t\telement.parentNode.removeChild(element);\n\t};\n\n\tDOMRenderer.createElements = function createElements(items) {\n\t\tvar elements = (0, _utils.$)(items.reduce(function (acc, v) {\n\t\t\treturn acc.concat(v.content);\n\t\t}, []).join(\"\"), _consts.MULTI);\n\n\t\treturn items.map(function (item, index) {\n\t\t\titem.el = elements[index];\n\t\t\treturn item;\n\t\t});\n\t};\n\n\tfunction DOMRenderer(element, options) {\n\t\t_classCallCheck(this, DOMRenderer);\n\n\t\t_extends(this.options = {\n\t\t\tisOverflowScroll: false,\n\t\t\tisEqualSize: false,\n\t\t\tisVertical: true\n\t\t}, options);\n\t\tthis._size = {\n\t\t\tcontainerOffset: 0,\n\t\t\tcontainer: -1,\n\t\t\tview: -1,\n\t\t\titem: null\n\t\t};\n\t\tthis._init(element);\n\t\tthis.resize();\n\t}\n\n\tDOMRenderer.prototype.getStatus = function getStatus() {\n\t\treturn {\n\t\t\tcssText: this.container.style.cssText,\n\t\t\toptions: _extends({}, this.options),\n\t\t\t_size: _extends({}, this._size)\n\t\t};\n\t};\n\n\tDOMRenderer.prototype.setStatus = function setStatus(status, items) {\n\t\tthis.container.style.cssText = status.cssText;\n\t\t_extends(this.options, status.options);\n\t\t_extends(this._size, status._size);\n\n\t\tDOMRenderer.renderItems(items);\n\t\tthis._insert(items, _consts.APPEND);\n\t};\n\n\tDOMRenderer.prototype.updateSize = function updateSize(items) {\n\t\tvar _this = this;\n\n\t\treturn items.map(function (item) {\n\t\t\tif (item.el) {\n\t\t\t\tif (_this.options.isEqualSize) {\n\t\t\t\t\t_this._size.item = _this._size.item || {\n\t\t\t\t\t\twidth: (0, _utils.innerWidth)(item.el),\n\t\t\t\t\t\theight: (0, _utils.innerHeight)(item.el)\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\titem.size = {\n\t\t\t\t\t\twidth: (0, _utils.innerWidth)(item.el),\n\t\t\t\t\t\theight: (0, _utils.innerHeight)(item.el)\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn item;\n\t\t});\n\t};\n\n\tDOMRenderer.prototype._init = function _init(el) {\n\t\tvar element = (0, _utils.$)(el);\n\n\t\tif (element.style.position === \"static\") {\n\t\t\telement.style.position = \"relative\";\n\t\t}\n\n\t\tif (this.options.isOverflowScroll) {\n\t\t\tvar container = element.querySelector(\".\" + _consts.CONTAINER_CLASSNAME);\n\n\t\t\tif (!container) {\n\t\t\t\tcontainer = document.createElement(\"div\");\n\t\t\t\tcontainer.className = _consts.CONTAINER_CLASSNAME;\n\n\t\t\t\tvar children = element.children;\n\t\t\t\tvar length = children.length; // for IE8\n\t\t\t\tvar target = this.options.isVertical ? [\"Y\", \"X\"] : [\"X\", \"Y\"];\n\n\t\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\t\tcontainer.appendChild(children[0]);\n\t\t\t\t}\n\n\t\t\t\telement.style[\"overflow\" + target[0]] = \"scroll\";\n\t\t\t\telement.style[\"overflow\" + target[1]] = \"hidden\";\n\t\t\t\telement.appendChild(container);\n\t\t\t}\n\t\t\tthis.view = element;\n\t\t\tthis.container = container;\n\t\t} else {\n\t\t\tthis.view = window;\n\t\t\tthis.container = element;\n\t\t}\n\t};\n\n\tDOMRenderer.prototype.append = function append(items) {\n\t\tthis._insert(items, _consts.APPEND, {\n\t\t\ttop: _consts.DUMMY_POSITION\n\t\t});\n\t};\n\n\tDOMRenderer.prototype.prepend = function prepend(items) {\n\t\tthis._insert(items, _consts.PREPEND, {\n\t\t\ttop: _consts.DUMMY_POSITION\n\t\t});\n\t};\n\n\tDOMRenderer.prototype.clear = function clear() {\n\t\tthis.container.innerHTML = \"\";\n\t\tthis.container.style[this.options.isVertical ? \"height\" : \"width\"] = \"\";\n\t\tthis._size = {\n\t\t\tcontainerOffset: 0,\n\t\t\tcontainer: -1,\n\t\t\tview: -1\n\t\t};\n\t};\n\n\tDOMRenderer.prototype.createAndInsert = function createAndInsert(items, isAppend) {\n\t\tvar itemsWithElement = DOMRenderer.createElements(items);\n\n\t\tDOMRenderer.renderItems(itemsWithElement);\n\t\tthis._insert(itemsWithElement, isAppend);\n\t};\n\n\tDOMRenderer.prototype._insert = function _insert(items, isAppend, styles) {\n\t\tvar df = document.createDocumentFragment();\n\n\t\titems.forEach(function (item) {\n\t\t\tstyles && DOMRenderer.renderItem(item, styles);\n\t\t\tisAppend ? df.appendChild(item.el) : df.insertBefore(item.el, df.firstChild);\n\t\t});\n\t\tisAppend ? this.container.appendChild(df) : this.container.insertBefore(df, this.container.firstChild);\n\t};\n\n\tDOMRenderer.prototype._calcSize = function _calcSize() {\n\t\treturn this.options.isVertical ? (0, _utils.innerWidth)(this.container) : (0, _utils.innerHeight)(this.container);\n\t};\n\n\tDOMRenderer.prototype.getViewSize = function getViewSize() {\n\t\treturn this._size.view;\n\t};\n\n\tDOMRenderer.prototype.scrollBy = function scrollBy(point) {\n\t\tvar pos = this.options.isVertical ? [0, point] : [point, 0];\n\n\t\t_utils.scrollBy.apply(undefined, [this.view].concat(pos));\n\t};\n\n\tDOMRenderer.prototype.getContainerOffset = function getContainerOffset() {\n\t\treturn this._size.containerOffset;\n\t};\n\n\tDOMRenderer.prototype.getContainerSize = function getContainerSize() {\n\t\tthis.resize();\n\t\treturn this._size.container;\n\t};\n\n\tDOMRenderer.prototype.setContainerSize = function setContainerSize(size) {\n\t\tthis.container.style[this.options.isVertical ? \"height\" : \"width\"] = size + \"px\";\n\t};\n\n\tDOMRenderer.prototype.resize = function resize() {\n\t\tif (this.isNeededResize()) {\n\t\t\tvar isVertical = this.options.isVertical;\n\n\t\t\tthis._size = {\n\t\t\t\tcontainerOffset: this.container[\"offset\" + (isVertical ? \"Top\" : \"Left\")],\n\t\t\t\tcontainer: this._calcSize(),\n\t\t\t\tview: isVertical ? (0, _utils.innerHeight)(this.view) : (0, _utils.innerWidth)(this.view),\n\t\t\t\titem: null\n\t\t\t};\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\tDOMRenderer.prototype.isNeededResize = function isNeededResize() {\n\t\treturn this._calcSize() !== this._size.container;\n\t};\n\n\tDOMRenderer.prototype.destroy = function destroy() {\n\t\tthis._size = {\n\t\t\tcontainerOffset: 0,\n\t\t\tcontainer: -1,\n\t\t\tview: -1,\n\t\t\titem: null\n\t\t};\n\t};\n\n\treturn DOMRenderer;\n}();\n\nexports[\"default\"] = DOMRenderer;\nmodule.exports = exports[\"default\"];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/DOMRenderer.js\n// module id = 3\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _consts = require(\"../consts\");\n\nvar _utils = require(\"../utils\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar START = _consts.ALIGN.START,\n    CENTER = _consts.ALIGN.CENTER,\n    END = _consts.ALIGN.END;\n\n/*\nFrame\n[\n[1, 1, 1, 1, 1],\n[0, 0, 2, 2, 2],\n[0, 0, 2, 2, 2],\n[3, 4, 5, 5, 5],\n]\n*/\n\nfunction disableFrame(frame, type, x, y, width, height) {\n\tfor (var i = y; i < y + height; ++i) {\n\t\tfor (var j = x; j < x + width; ++j) {\n\t\t\tif (type !== frame[i][j]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tframe[i][j] = 0;\n\t\t}\n\t}\n}\nfunction searchShapeInFrame(frame, type, top, left, width, height) {\n\tvar size = {\n\t\tleft: left,\n\t\ttop: top,\n\t\ttype: type,\n\t\twidth: 1,\n\t\theight: 1\n\t};\n\n\tfor (var i = left; i < width; ++i) {\n\t\tif (frame[top][i] === type) {\n\t\t\tsize.width = i - left + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tfor (var _i = top; _i < height; ++_i) {\n\t\tif (frame[_i][left] === type) {\n\t\t\tsize.height = _i - top + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\t// After finding the shape, it will not find again.\n\tdisableFrame(frame, type, left, top, size.width, size.height);\n\treturn size;\n}\nfunction getShapes(frame) {\n\tvar height = frame.length;\n\tvar width = height ? frame[0].length : 0;\n\tvar shapes = [];\n\n\tfor (var i = 0; i < height; ++i) {\n\t\tfor (var j = 0; j < width; ++j) {\n\t\t\tvar type = frame[i][j];\n\n\t\t\tif (!type) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// Separate shapes with other numbers.\n\t\t\tshapes.push(searchShapeInFrame(frame, type, i, j, width, height));\n\t\t}\n\t}\n\tshapes.sort(function (a, b) {\n\t\treturn a.type < b.type ? -1 : 1;\n\t});\n\treturn {\n\t\tshapes: shapes,\n\t\twidth: width,\n\t\theight: height\n\t};\n}\n\nvar FrameLayout = function () {\n\tfunction FrameLayout() {\n\t\tvar options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t_classCallCheck(this, FrameLayout);\n\n\t\tthis.options = (0, _utils.assignOptions)({\n\t\t\titemSize: 0,\n\t\t\tframe: [],\n\t\t\tfitSize: 0,\n\t\t\talign: START,\n\t\t\tframeFill: true\n\t\t}, options);\n\t\tvar frame = this.options.frame.map(function (row) {\n\t\t\treturn row.slice();\n\t\t});\n\t\t// divide frame into shapes.\n\t\tvar shapes = getShapes(frame);\n\n\t\tthis._itemSize = this.options.itemSize || 0;\n\t\tthis._shapes = shapes;\n\t\tthis._size = 0;\n\t\tthis._style = (0, _utils.getStyleNames)(this.options.direction);\n\t}\n\n\tFrameLayout.prototype._getItemSize = function _getItemSize() {\n\t\tthis._checkItemSize();\n\n\t\treturn this._itemSize;\n\t};\n\n\tFrameLayout.prototype._checkItemSize = function _checkItemSize() {\n\t\tif (this.options.itemSize) {\n\t\t\tthis._itemSize = this.options.itemSize;\n\t\t\treturn;\n\t\t}\n\t\tvar style = this._style;\n\t\tvar size = style.size2;\n\t\tvar margin = this.options.margin;\n\n\t\t// if itemSize is not in options, caculate itemSize from size.\n\t\tthis._itemSize = (this._size + margin) / this._shapes[size] - margin;\n\t};\n\n\tFrameLayout.prototype._layout = function _layout(items) {\n\t\tvar outline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\t\tvar isAppend = arguments[2];\n\n\t\tvar length = items.length;\n\t\tvar style = this._style;\n\t\tvar _options = this.options,\n\t\t    margin = _options.margin,\n\t\t    align = _options.align,\n\t\t    frameFill = _options.frameFill;\n\n\t\tvar size1Name = style.size1;\n\t\tvar size2Name = style.size2;\n\t\tvar pos1Name = style.pos1;\n\t\tvar pos2Name = style.pos2;\n\t\tvar itemSize = this._getItemSize();\n\t\tvar isItemObject = (typeof itemSize === \"undefined\" ? \"undefined\" : _typeof(itemSize)) === \"object\";\n\t\tvar itemSize2 = isItemObject ? itemSize[size2Name] : itemSize;\n\t\tvar itemSize1 = isItemObject ? itemSize[size1Name] : itemSize;\n\t\tvar shapesSize = this._shapes[size2Name];\n\t\tvar shapes = this._shapes.shapes;\n\t\tvar shapesLength = shapes.length;\n\t\tvar startOutline = new Array(shapesSize).fill(-1);\n\t\tvar endOutline = new Array(shapesSize).fill(0);\n\t\tvar shapesSize1 = shapes.height * (itemSize1 + margin) - margin;\n\t\tvar fitSize = this.options.fitSize;\n\t\tvar fitStartPos = 0;\n\n\t\tif (fitSize < shapesSize1) {\n\t\t\tfitSize = 0;\n\t\t}\n\t\tif (fitSize) {\n\t\t\tif (align === CENTER) {\n\t\t\t\tfitStartPos = (fitSize - shapesSize1) / 2;\n\t\t\t} else if (align === END) {\n\t\t\t\tfitStartPos = fitSize - shapesSize1;\n\t\t\t}\n\t\t}\n\t\tvar dist = 0;\n\t\tvar end = 0;\n\t\tvar startIndex = -1;\n\t\tvar endIndex = -1;\n\t\tvar minPos = -1;\n\t\tvar maxPos = -1;\n\n\t\tif (!shapesLength) {\n\t\t\treturn { start: outline, end: outline, startIndex: startIndex, endIndex: endIndex };\n\t\t}\n\t\tfor (var i = 0; i < length; i += shapesLength) {\n\t\t\tfor (var j = 0; j < shapesLength && i + j < length; ++j) {\n\t\t\t\tvar _item$rect;\n\n\t\t\t\tvar item = items[i + j];\n\t\t\t\tvar shape = shapes[j];\n\t\t\t\tvar shapePos1 = shape[pos1Name];\n\t\t\t\tvar shapePos2 = shape[pos2Name];\n\t\t\t\tvar shapeSize1 = shape[size1Name];\n\t\t\t\tvar shapeSize2 = shape[size2Name];\n\t\t\t\tvar pos1 = end - dist + shapePos1 * (itemSize1 + margin) + fitStartPos;\n\t\t\t\tvar pos2 = shapePos2 * (itemSize2 + margin);\n\t\t\t\tvar size1 = shapeSize1 * (itemSize1 + margin) - margin;\n\t\t\t\tvar size2 = shapeSize2 * (itemSize2 + margin) - margin;\n\n\t\t\t\tfor (var k = shapePos2; k < shapePos2 + shapeSize2 && k < shapesSize; ++k) {\n\t\t\t\t\tif (startOutline[k] === -1) {\n\t\t\t\t\t\tstartOutline[k] = pos1;\n\t\t\t\t\t}\n\t\t\t\t\tif (startIndex === -1) {\n\t\t\t\t\t\tminPos = pos1;\n\t\t\t\t\t\tstartIndex = i + j;\n\t\t\t\t\t\tmaxPos = pos1 + size1 + margin;\n\t\t\t\t\t\tendIndex = i + j;\n\t\t\t\t\t}\n\t\t\t\t\tif (minPos > pos1) {\n\t\t\t\t\t\tminPos = pos1;\n\t\t\t\t\t\tstartIndex = i + j;\n\t\t\t\t\t}\n\t\t\t\t\tif (maxPos < pos1 + size1 + margin) {\n\t\t\t\t\t\tmaxPos = pos1 + size1 + margin;\n\t\t\t\t\t\tendIndex = i + j;\n\t\t\t\t\t}\n\t\t\t\t\tstartOutline[k] = Math.min(startOutline[k], pos1);\n\t\t\t\t\tendOutline[k] = Math.max(endOutline[k], pos1 + size1 + margin);\n\t\t\t\t}\n\t\t\t\titem.rect = (_item$rect = {}, _item$rect[pos1Name] = pos1, _item$rect[pos2Name] = pos2, _item$rect[size1Name] = size1, _item$rect[size2Name] = size2, _item$rect);\n\t\t\t}\n\t\t\tif (fitSize) {\n\t\t\t\tfor (var _k = 0; _k < shapesSize; ++_k) {\n\t\t\t\t\tendOutline[_k] = end + fitSize;\n\t\t\t\t}\n\t\t\t}\n\t\t\tend = Math.max.apply(Math, endOutline);\n\t\t\t// check dist once\n\t\t\tif (i !== 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// find & fill empty block\n\t\t\tif (!frameFill) {\n\t\t\t\tdist = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdist = end;\n\t\t\tfor (var _j = 0; _j < shapesSize; ++_j) {\n\t\t\t\tif (startOutline[_j] === -1) {\n\t\t\t\t\tstartOutline[_j] = Math.max.apply(Math, startOutline);\n\t\t\t\t\tendOutline[_j] = startOutline[_j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// the dist between frame's end outline and next frame's start outline\n\t\t\t\t// expect that next frame's start outline is startOutline[j] + end\n\t\t\t\tdist = Math.min(startOutline[_j] + end - endOutline[_j], dist);\n\t\t\t}\n\t\t}\n\t\t// The target outline is start outline when type is APPENDING\n\t\tvar targetOutline = isAppend ? startOutline : endOutline;\n\t\tvar prevOutlineEnd = outline.length === 0 ? 0 : Math[isAppend ? \"max\" : \"min\"].apply(Math, outline);\n\t\tvar prevOutlineDist = isAppend ? 0 : end;\n\n\t\tif (frameFill && outline.length === shapesSize) {\n\t\t\tprevOutlineDist = isAppend ? Math.abs(prevOutlineEnd) : 0;\n\t\t\tfor (var _i2 = 0; _i2 < shapesSize; ++_i2) {\n\t\t\t\tif (startOutline[_i2] === endOutline[_i2]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// if appending type is PREPEND, subtract dist from appending group's height.\n\t\t\t\tprevOutlineDist = Math[isAppend ? \"min\" : \"max\"](targetOutline[_i2] + prevOutlineEnd - outline[_i2], prevOutlineDist);\n\t\t\t}\n\t\t}\n\t\tfor (var _i3 = 0; _i3 < shapesSize; ++_i3) {\n\t\t\tstartOutline[_i3] += prevOutlineEnd - prevOutlineDist;\n\t\t\tendOutline[_i3] += prevOutlineEnd - prevOutlineDist;\n\t\t}\n\t\titems.forEach(function (item) {\n\t\t\titem.rect[pos1Name] += prevOutlineEnd - prevOutlineDist;\n\t\t});\n\t\treturn {\n\t\t\tstart: startOutline,\n\t\t\tend: endOutline,\n\t\t\tstartIndex: startIndex,\n\t\t\tendIndex: endIndex\n\t\t};\n\t};\n\n\tFrameLayout.prototype._insert = function _insert(items, outline, type) {\n\t\t// this only needs the size of the item.\n\t\tvar clone = items.map(function (item) {\n\t\t\treturn _extends({}, item);\n\t\t});\n\n\t\treturn {\n\t\t\titems: clone,\n\t\t\toutlines: this._layout(clone, outline, type)\n\t\t};\n\t};\n\n\tFrameLayout.prototype.layout = function layout(groups, outlines) {\n\t\tvar length = groups.length;\n\t\tvar point = outlines;\n\n\t\tfor (var i = 0; i < length; ++i) {\n\t\t\tvar group = groups[i];\n\n\t\t\tpoint = this._layout(group.items, point, _consts.APPEND);\n\t\t\tgroup.outlines = point;\n\t\t\tpoint = point.end;\n\t\t}\n\t};\n\n\tFrameLayout.prototype.append = function append(items, outline) {\n\t\treturn this._insert(items, outline, _consts.APPEND);\n\t};\n\n\tFrameLayout.prototype.prepend = function prepend(items, outline) {\n\t\treturn this._insert(items, outline, _consts.PREPEND);\n\t};\n\n\tFrameLayout.prototype.setSize = function setSize(size) {\n\t\tthis._size = size;\n\t};\n\n\treturn FrameLayout;\n}();\n\nexports[\"default\"] = FrameLayout;\nmodule.exports = exports[\"default\"];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/layouts/FrameLayout.js\n// module id = 4\n// module chunks = 0 1","\"use strict\";\n\nvar _InfiniteGrid = require(\"./InfiniteGrid\");\n\nvar _InfiniteGrid2 = _interopRequireDefault(_InfiniteGrid);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nmodule.exports = _InfiniteGrid2[\"default\"]; /**\n                                             * Copyright (c) NAVER Corp.\n                                             * egjs-infinitegrid projects are licensed under the MIT license\n                                             */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.js\n// module id = 5\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; /**\n                                                                                                                                                                                                                                                                               * Copyright (c) 2017 NAVER Corp.\n                                                                                                                                                                                                                                                                               * egjs projects are licensed under the MIT license\n                                                                                                                                                                                                                                                                              */\n\n\nvar _component = require(\"@egjs/component\");\n\nvar _component2 = _interopRequireDefault(_component);\n\nvar _ItemManager = require(\"./ItemManager\");\n\nvar _ItemManager2 = _interopRequireDefault(_ItemManager);\n\nvar _DOMRenderer = require(\"./DOMRenderer\");\n\nvar _DOMRenderer2 = _interopRequireDefault(_DOMRenderer);\n\nvar _ImageLoaded = require(\"./ImageLoaded\");\n\nvar _ImageLoaded2 = _interopRequireDefault(_ImageLoaded);\n\nvar _Watcher = require(\"./Watcher\");\n\nvar _Watcher2 = _interopRequireDefault(_Watcher);\n\nvar _GridLayout = require(\"./layouts/GridLayout\");\n\nvar _GridLayout2 = _interopRequireDefault(_GridLayout);\n\nvar _FrameLayout = require(\"./layouts/FrameLayout\");\n\nvar _FrameLayout2 = _interopRequireDefault(_FrameLayout);\n\nvar _SquareLayout = require(\"./layouts/SquareLayout\");\n\nvar _SquareLayout2 = _interopRequireDefault(_SquareLayout);\n\nvar _PackingLayout = require(\"./layouts/PackingLayout\");\n\nvar _PackingLayout2 = _interopRequireDefault(_PackingLayout);\n\nvar _JustifiedLayout = require(\"./layouts/JustifiedLayout\");\n\nvar _JustifiedLayout2 = _interopRequireDefault(_JustifiedLayout);\n\nvar _consts = require(\"./consts\");\n\nvar _utils = require(\"./utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// IE8\n// https://stackoverflow.com/questions/43216659/babel-ie8-inherit-issue-with-object-create\n/* eslint-disable */\nif (typeof Object.create !== \"function\") {\n\tObject.create = function (o, properties) {\n\t\tif ((typeof o === \"undefined\" ? \"undefined\" : _typeof(o)) !== \"object\" && typeof o !== \"function\") {\n\t\t\tthrow new TypeError(\"Object prototype may only be an Object: \" + o);\n\t\t} else if (o === null) {\n\t\t\tthrow new Error(\"This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument.\");\n\t\t}\n\t\tfunction F() {}\n\t\tF.prototype = o;\n\t\treturn new F();\n\t};\n}\n/* eslint-enable */\n\n/**\n * A module used to arrange card elements including content infinitely according to layout type. With this module, you can implement various layouts composed of different card elements whose sizes vary. It guarantees performance by maintaining the number of DOMs the module is handling under any circumstance\n * @ko 콘텐츠가 있는 카드 엘리먼트를 레이아웃 타입에 따라 무한으로 배치하는 모듈. 다양한 크기의 카드 엘리먼트를 다양한 레이아웃으로 배치할 수 있다. 카드 엘리먼트의 개수가 계속 늘어나도 모듈이 처리하는 DOM의 개수를 일정하게 유지해 최적의 성능을 보장한다\n * @alias eg.InfiniteGrid\n * @extends eg.Component\n *\n * @example\n```\n<ul id=\"grid\">\n\t<li class=\"card\">\n\t\t<div>test1</div>\n\t</li>\n\t<li class=\"card\">\n\t\t<div>test2</div>\n\t</li>\n\t<li class=\"card\">\n\t\t<div>test3</div>\n\t</li>\n\t<li class=\"card\">\n\t\t<div>test4</div>\n\t</li>\n\t<li class=\"card\">\n\t\t<div>test5</div>\n\t</li>\n\t<li class=\"card\">\n\t\t<div>test6</div>\n\t</li>\n</ul>\n<script>\nvar some = new eg.InfiniteGrid(\"#grid\").on(\"layoutComplete\", function(e) {\n\t// ...\n});\n</script>\n```\n *\n * @support {\"ie\": \"8+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\", \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"2.1+ (except 3.x)\"}\n **/\n\nvar InfiniteGrid = function (_Component) {\n\t_inherits(InfiniteGrid, _Component);\n\n\t/**\n  * @param {HTMLElement|String|jQuery} element A base element for a module <ko>모듈을 적용할 기준 엘리먼트</ko>\n  * @param {Object} [options] The option object of the eg.InfiniteGrid module <ko>eg.InfiniteGrid 모듈의 옵션 객체</ko>\n  * @param {String} [options.itemSelector] A selector to select card elements that make up the layout<ko>레이아웃을 구성하는 카드 엘리먼트를 선택할 선택자(selector)</ko>\n  * @param {Boolean} [options.useRecycle=true] Indicates whether keep the number of DOMs is maintained. If the useRecycle value is 'true', keep the number of DOMs is maintained. If the useRecycle value is 'false', the number of DOMs will increase as card elements are added. <ko>DOM의 수를 유지할지 여부를 나타낸다. useRecycle 값이 'true'이면 DOM 개수를 일정하게 유지한다. useRecycle 값이 'false' 이면 카드 엘리먼트가 추가될수록 DOM 개수가 계속 증가한다.</ko>\n  * @param {Boolean} [options.isOverflowScroll=false] Indicates whether overflow:scroll is applied<ko>overflow:scroll 적용여부를 결정한다.</ko>\n  * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (true: horizontal, false: vertical) <ko>스크롤 이동 방향 (true 가로방향, false 세로방향</ko>\n  * @param {Boolean} [options.isEqualSize=false] Indicates whether sizes of all card elements are equal to one another. If sizes of card elements to be arranged are all equal and this option is set to \"true\", the performance of layout arrangement can be improved. <ko>카드 엘리먼트의 크기가 동일한지 여부. 배치될 카드 엘리먼트의 크기가 모두 동일할 때 이 옵션을 'true'로 설정하면 레이아웃 배치 성능을 높일 수 있다</ko>\n  * @param {Number} [options.threshold=300] The threshold size of an event area where card elements are added to a layout.<ko>레이아웃에 카드 엘리먼트를 추가하는 이벤트가 발생하는 기준 영역의 크기.</ko>\n  *\n  */\n\tfunction InfiniteGrid(element, options) {\n\t\t_classCallCheck(this, InfiniteGrid);\n\n\t\tvar _this = _possibleConstructorReturn(this, _Component.call(this));\n\n\t\t_extends(_this.options = {\n\t\t\titemSelector: \"*\",\n\t\t\tisOverflowScroll: false,\n\t\t\tthreshold: 300,\n\t\t\tisEqualSize: false,\n\t\t\tuseRecycle: true,\n\t\t\thorizontal: false\n\t\t}, options);\n\t\t_consts.IS_ANDROID2 && (_this.options.isOverflowScroll = false);\n\t\t_this._isVertical = !_this.options.horizontal;\n\t\t_this._reset();\n\t\t_this._items = new _ItemManager2[\"default\"]();\n\t\t_this._renderer = new _DOMRenderer2[\"default\"](element, {\n\t\t\tisOverflowScroll: _this.options.isOverflowScroll,\n\t\t\tisEqualSize: _this.options.isEqualSize,\n\t\t\tisVertical: _this._isVertical\n\t\t});\n\t\t_this._watcher = new _Watcher2[\"default\"](_this._renderer, {\n\t\t\tlayout: function layout() {\n\t\t\t\treturn _this.layout();\n\t\t\t},\n\t\t\tcheck: function check(param) {\n\t\t\t\treturn _this._onCheck(param);\n\t\t\t}\n\t\t});\n\t\treturn _this;\n\t}\n\t/**\n  * Adds a card element at the bottom of a layout. This method is available only if the isProcessing() method returns false.\n  * @ko 카드 엘리먼트를 레이아웃 아래에 추가한다. isProcessing() 메서드의 반환값이 'false'일 때만 이 메서드를 사용할 수 있다\n  * 이 메소드는 isProcessing()의 반환값이 false일 경우에만 사용 가능하다.\n  * @param {Array|jQuery} elements Array of the card elements to be added <ko>추가할 카드 엘리먼트의 배열</ko>\n  * @param {Number|String} [groupKey] The group key to be configured in a card element. It is automatically generated by default.\n  * <ko>추가할 카드 엘리먼트에 설정할 그룹 키. 생략하면 값이 자동으로 생성된다.</ko>\n  * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n  * @example\n  * infinitegrid.append(\"&lt;div class='item'&gt;test1&lt;/div&gt;&lt;div class='item'&gt;test2&lt;/div&gt;\");\n  * infinitegrid.append([\"&lt;div class='item'&gt;test1&lt;/div&gt;\", \"&lt;div class='item'&gt;test2&lt;/div&gt;\"]);\n  * infinitegrid.append([HTMLElement1, HTMLElement2]);\n  * infinitegrid.append(jQuery([\"&lt;div class='item'&gt;test1&lt;/div&gt;\", \"&lt;div class='item'&gt;test2&lt;/div&gt;\"]));\n  */\n\n\n\tInfiniteGrid.prototype.append = function append(elements, groupKey) {\n\t\tthis._layout && this._insert(elements, _consts.APPEND, groupKey);\n\t\treturn this;\n\t};\n\t/**\n  * Adds a card element at the top of a layout. This method is available only if the isProcessing() method returns false.\n  * @ko 카드 엘리먼트를 레이아웃의 위에 추가한다. isProcessing() 메서드의 반환값이 'false'일 때만 이 메서드를 사용할 수 있다\n  * @param {Array|jQuery} elements Array of the card elements to be added <ko>추가할 카드 엘리먼트 배열</ko>\n  * @param {Number|String} [groupKey] The group key to be configured in a card element. It is automatically generated by default.\n  * <ko>추가할 카드 엘리먼트에 설정할 그룹 키. 생략하면 값이 자동으로 생성된다.</ko>\n  * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n  * @example\n  * infinitegrid.prepend(\"&lt;div class='item'&gt;test1&lt;/div&gt;&lt;div class='item'&gt;test2&lt;/div&gt;\");\n  * infinitegrid.prepend([\"&lt;div class='item'&gt;test1&lt;/div&gt;\", \"&lt;div class='item'&gt;test2&lt;/div&gt;\"]);\n  * infinitegrid.prepend([HTMLElement1, HTMLElement2]);\n  * infinitegrid.prepend(jQuery([\"&lt;div class='item'&gt;test1&lt;/div&gt;\", \"&lt;div class='item'&gt;test2&lt;/div&gt;\"]));\n  */\n\n\n\tInfiniteGrid.prototype.prepend = function prepend(elements, groupKey) {\n\t\tthis._layout && this._insert(elements, _consts.PREPEND, groupKey);\n\t\treturn this;\n\t};\n\t/**\n  * Specifies the Layout class to use.\n  * @ko 사용할 Layout 클래스를 지정한다.\n  * @param {Class} LayoutKlass The Layout class to use <ko>사용할 Layout 클래스</ko>\n  * @param {Object} options Options to apply to the Layout.<ko>Layout에 적용할 옵션</ko>\n  * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n  * @example\n  * infinitegrid.setLayout(eg.InfiniteGrid.GridLayout, {\n  *  margin: 10,\n  *  align: \"start\"\n  * });\n   * infinitegrid.setLayout(eg.InfiniteGrid.JustifiedLayout, {\n  *  margin: 10,\n  *  minSize: 100,\n  *  maxSize: 200\n  * });\n   * infinitegrid.setLayout(eg.InfiniteGrid.SquareLayout, {\n  *  margin: 10,\n  *  column: 2\n  * });\n  * infinitegrid.setLayout(eg.InfiniteGrid.FrameLayout, {\n  *  margin: 10,\n  *  frame: [\n  *   [1, 2],\n   *   [4, 3],\n  *  ]\n  * });\n  * infinitegrid.setLayout(eg.InfiniteGrid.PackingLayout, {\n  *  margin: 10,\n  *  aspectRatio: 1.5\n  * });\n  */\n\n\n\tInfiniteGrid.prototype.setLayout = function setLayout(LayoutKlass, options) {\n\t\tthis._layout = new LayoutKlass(_extends(options || {}, {\n\t\t\tdirection: this._isVertical ? \"vertical\" : \"horizontal\"\n\t\t}));\n\t\tthis._layout.setSize(this._renderer.getContainerSize());\n\t\treturn this;\n\t};\n\t/**\n  * Returns the layouted items.\n  * @ko 레이아웃된 아이템들을 반환한다.\n  * @param {Boolean} includeCached Indicates whether to include the cached items. <ko>캐싱된 아이템을 포함할지 여부를 나타낸다.</ko>\n  * @returns {Array} List of items <ko>아이템의 목록</ko>\n  */\n\n\n\tInfiniteGrid.prototype.getItems = function getItems() {\n\t\tvar includeCached = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n\t\treturn this[includeCached ? \"_getItems\" : \"_getVisibleItems\"]();\n\t};\n\n\tInfiniteGrid.prototype._getItems = function _getItems() {\n\t\treturn this._items.pluck(\"items\", 0, this._items.size());\n\t};\n\n\tInfiniteGrid.prototype._getVisibleItems = function _getVisibleItems() {\n\t\treturn this._items.pluck(\"items\", this._status.startCursor, this._status.endCursor);\n\t};\n\n\tInfiniteGrid.prototype._updateEdge = function _updateEdge() {\n\t\tthis._status.start = this._items.getEdge(\"start\", this._status.startCursor, this._status.endCursor);\n\t\tthis._status.end = this._items.getEdge(\"end\", this._status.startCursor, this._status.endCursor);\n\t};\n\n\tInfiniteGrid.prototype._getEdgeOffset = function _getEdgeOffset(cursor) {\n\t\tvar rect = null;\n\n\t\tif (!this._status[cursor]) {\n\t\t\tvar item = this._items.getEdge(cursor);\n\n\t\t\tthis._status[cursor] = item;\n\t\t}\n\n\t\tif (this._status[cursor]) {\n\t\t\trect = this._status[cursor].rect;\n\t\t\tif (cursor === \"start\") {\n\t\t\t\trect.bottom = rect.top + this._status[cursor].size.height;\n\t\t\t\trect.right = rect.left + this._status[cursor].size.width;\n\t\t\t}\n\t\t}\n\t\treturn rect;\n\t};\n\t// called by visible\n\n\n\tInfiniteGrid.prototype._fit = function _fit() {\n\t\tvar scrollCycle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"after\";\n\n\t\t// for caching\n\t\tif (!this.options.useRecycle) {\n\t\t\tthis._fit = function () {};\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._layout) {\n\t\t\tvar base = this._getEdgeValue(\"start\");\n\n\t\t\tif (base !== 0) {\n\t\t\t\tif (scrollCycle === \"before\") {\n\t\t\t\t\tthis._renderer.scrollBy(-Math.abs(base));\n\t\t\t\t\tthis._watcher.setScrollPos();\n\t\t\t\t}\n\t\t\t\tthis._items.fit(base, this._isVertical);\n\t\t\t\t_DOMRenderer2[\"default\"].renderItems(this._getVisibleItems());\n\t\t\t\tthis._renderer.setContainerSize(this._getEdgeValue(\"end\"));\n\t\t\t\tif (scrollCycle === \"after\") {\n\t\t\t\t\tthis._renderer.scrollBy(Math.abs(base));\n\t\t\t\t\tthis._watcher.setScrollPos();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tInfiniteGrid.prototype._getEdgeValue = function _getEdgeValue(cursor) {\n\t\treturn this._items.getEdgeValue(cursor, this._status.startCursor, this._status.endCursor);\n\t};\n\t/**\n  * Rearranges a layout.\n  * @ko 레이아웃을 다시 배치한다.\n  * @param {Boolean} [isRelayout=true] Indicates whether a card element is being relayouted <ko>카드 엘리먼트 재배치 여부</ko>\n  * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n  */\n\n\n\tInfiniteGrid.prototype.layout = function layout() {\n\t\tvar _this2 = this;\n\n\t\tvar isRelayout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n\t\tif (!this._layout || this.isProcessing()) {\n\t\t\treturn this;\n\t\t}\n\t\t// check childElement\n\t\tif (!this._items.size()) {\n\t\t\tthis._insert((0, _utils.toArray)(this._renderer.container.children), true);\n\t\t\treturn this;\n\t\t} else {\n\t\t\tthis._status.isProcessing = true;\n\n\t\t\tvar data = void 0;\n\t\t\tvar outline = void 0;\n\n\t\t\tif (isRelayout) {\n\t\t\t\t// remove cache\n\t\t\t\tdata = this._items.get(this._status.startCursor, this._status.endCursor);\n\t\t\t\tif (this._renderer.resize()) {\n\t\t\t\t\tthis._layout.setSize(this._renderer.getContainerSize());\n\t\t\t\t\tdata.forEach(function (v) {\n\t\t\t\t\t\tdata.items = _this2._renderer.updateSize(v.items);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdata = this._items.get(this._status.startCursor, this._items.size());\n\t\t\t\toutline = this._items.getOutline(this._status.startCursor, \"start\");\n\t\t\t}\n\t\t\tif (!data.length) {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tthis._layout.layout(data, outline);\n\n\t\t\tif (isRelayout) {\n\t\t\t\tthis._items.set(data);\n\t\t\t\tthis._status.startCursor = 0;\n\t\t\t\tthis._status.endCursor = data.length - 1;\n\t\t\t} else {\n\t\t\t\tdata.forEach(function (v) {\n\t\t\t\t\treturn _this2._items.set(v, v.groupKey);\n\t\t\t\t});\n\t\t\t}\n\t\t\tthis._onLayoutComplete(data, _consts.APPEND, _consts.NO_TRUSTED);\n\t\t\t_DOMRenderer2[\"default\"].renderItems(this._getVisibleItems());\n\t\t\tisRelayout && this._watcher.setScrollPos();\n\t\t}\n\n\t\treturn this;\n\t};\n\t/**\n  * Removes a item element on a grid layout.\n  * @ko 그리드 레이아웃의 카드 엘리먼트를 삭제한다.\n  * @param {HTMLElement} item element to be removed <ko>삭제될 아이템 엘리먼트</ko>\n  * @return {Object}  Removed item element <ko>삭제된 아이템 엘리먼트 정보</ko>\n  */\n\n\n\tInfiniteGrid.prototype.remove = function remove(element) {\n\t\tif (element) {\n\t\t\tvar items = this._items.remove(element, this._status.startCursor, this._status.endCursor);\n\n\t\t\tif (items) {\n\t\t\t\t_DOMRenderer2[\"default\"].removeElement(element);\n\t\t\t\treturn items;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n\n\tInfiniteGrid.prototype._getNextItems = function _getNextItems(isAppend) {\n\t\tvar items = [];\n\t\tvar size = this._items.size();\n\n\t\t// from cache\n\t\tif (size > 0 && this._status.startCursor !== -1 && this._status.endCursor !== -1) {\n\t\t\tif (isAppend && size > this._status.endCursor + 1) {\n\t\t\t\titems = this._items.pluck(\"items\", this._status.endCursor + 1);\n\t\t\t} else if (!isAppend && this._status.startCursor > 0) {\n\t\t\t\titems = this._items.pluck(\"items\", this._status.startCursor - 1);\n\t\t\t}\n\t\t}\n\t\treturn items;\n\t};\n\t/**\n  * Returns the list of group keys which belongs to card elements currently being maintained. You can use the append() or prepend() method to configure group keys so that multiple card elements can be managed at once. If you do not use these methods to configure group keys, groupkey is automatically generated.\n  * @ko 현재 유지하고 있는 카드 엘리먼트의 그룹 키 목록을 반환한다. 여러 개의 카드 엘리먼트를 묶어서 관리할 수 있도록 append() 메서드나 prepend() 메서드에서 그룹 키를 지정할 수 있다. append() 메서드나 prepend() 메서드에서 그룹 키를 지정하지 않았다면 자동으로 그룹키가 생성된다.\n  * @param {Boolean} includeCached Indicates whether to include the cached groups. <ko>캐싱된 그룹을 포함할지 여부를 나타낸다.</ko>\n  * @return {Array} List of group keys <ko>그룹 키의 목록</ko>\n  */\n\n\n\tInfiniteGrid.prototype.getGroupKeys = function getGroupKeys(includeCached) {\n\t\tvar data = includeCached ? this._items.get() : this._items.get(this._status.startCursor, this._status.endCursor);\n\n\t\treturn data.map(function (v) {\n\t\t\treturn v.groupKey;\n\t\t});\n\t};\n\t/**\n  * Returns the current state of a module such as location information. You can use the setStatus() method to restore the information returned through a call to this method.\n  * @ko 카드의 위치 정보 등 모듈의 현재 상태 정보를 반환한다. 이 메서드가 반환한 정보를 저장해 두었다가 setStatus() 메서드로 복원할 수 있다\n  * @return {Object} State object of the eg.InfiniteGrid module<ko>eg.InfiniteGrid 모듈의 상태 객체</ko>\n  */\n\n\n\tInfiniteGrid.prototype.getStatus = function getStatus() {\n\t\treturn {\n\t\t\toptions: _extends({}, this.options),\n\t\t\t_status: _extends({}, this._status),\n\t\t\t_items: this._items.getStatus(),\n\t\t\t_renderer: this._renderer.getStatus(),\n\t\t\t_watcher: this._watcher.getStatus()\n\t\t};\n\t};\n\t/**\n  * Sets the state of the eg.InfiniteGrid module with the information returned through a call to the getStatue() method.\n  * @ko getStatue() 메서드가 저장한 정보로 eg.InfiniteGrid 모듈의 상태를 설정한다.\n  * @param {Object} status State object of the eg.InfiniteGrid module <ko>eg.InfiniteGrid 모듈의 상태 객체</ko>\n  * @param {boolean} [applyScrollPos=true] Checks whether to scroll<ko>스크롤의 위치를 복원할지 결정한다.</ko>\n  * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n  */\n\n\n\tInfiniteGrid.prototype.setStatus = function setStatus(status) {\n\t\tvar applyScrollPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n\t\tif (!status || !status.options || !status._status || !status._renderer || !status._items || !status._watcher) {\n\t\t\treturn this;\n\t\t}\n\t\tthis._watcher.detachEvent();\n\t\t_extends(this.options, status.options);\n\t\t_extends(this._status, status._status);\n\t\tthis._items.setStatus(status._items, this._status.startCursor, this._status.endCursor);\n\t\tthis._renderer.setStatus(status._renderer, this._getVisibleItems());\n\t\tthis._watcher.setStatus(status._watcher, applyScrollPos);\n\t\tthis._updateEdge();\n\t\tthis._watcher.attachEvent();\n\t\treturn this;\n\t};\n\t/**\n  * Clears added card elements and data.\n  * @ko 추가된 카드 엘리먼트와 데이터를 모두 지운다.\n  * @return {eg.InfiniteGrid} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n  */\n\n\n\tInfiniteGrid.prototype.clear = function clear() {\n\t\tthis._items.clear();\n\t\tthis._renderer.clear();\n\t\tthis._reset();\n\t\treturn this;\n\t};\n\t/**\n  * Checks whether a card element is being added.\n  * @ko 카드 엘리먼트 추가가 진행 중인지 확인한다\n  * @return {Boolean} Indicates whether a card element is being added <ko>카드 엘리먼트 추가 진행 중 여부</ko>\n  */\n\n\n\tInfiniteGrid.prototype.isProcessing = function isProcessing() {\n\t\treturn this._status.isProcessing;\n\t};\n\n\tInfiniteGrid.prototype._insert = function _insert(elements, isAppend, groupKey) {\n\t\tif (this.isProcessing() || elements.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tthis._status.isProcessing = true;\n\t\tvar key = typeof groupKey === \"undefined\" ? new Date().getTime() + Math.floor(Math.random() * 1000) : groupKey;\n\t\tvar items = _ItemManager2[\"default\"].from((0, _utils.$)(elements, true), this.options.itemSelector, {\n\t\t\tisAppend: isAppend,\n\t\t\tgroupKey: key\n\t\t});\n\n\t\tif (!items.length) {\n\t\t\treturn;\n\t\t}\n\t\tthis._postLayout(_consts.NO_CACHE, items, isAppend, _consts.NO_TRUSTED);\n\t};\n\t// add items, and remove items for recycling\n\n\n\tInfiniteGrid.prototype._recycle = function _recycle(isAppend) {\n\t\tvar remove = [];\n\n\t\tfor (var i = this._status.startCursor; i <= this._status.endCursor; i++) {\n\t\t\tremove.push(this._isVisible(i));\n\t\t}\n\t\tvar start = remove.indexOf(isAppend ? 1 : -1);\n\t\tvar end = remove.lastIndexOf(isAppend ? 1 : -1);\n\n\t\tif (start !== -1 && end !== -1) {\n\t\t\tstart = this._status.startCursor + start;\n\t\t\tend = start + end;\n\t\t\t_DOMRenderer2[\"default\"].removeItems(this._items.pluck(\"items\", start, end));\n\t\t\tif (isAppend) {\n\t\t\t\tthis._status.startCursor = end + 1;\n\t\t\t} else {\n\t\t\t\tthis._status.endCursor = start - 1;\n\t\t\t}\n\t\t}\n\t};\n\n\tInfiniteGrid.prototype._postLayout = function _postLayout(fromCache, items, isAppend, isTrusted) {\n\t\tvar _this3 = this;\n\n\t\tif (fromCache) {\n\t\t\tthis._renderer.createAndInsert(items, isAppend);\n\t\t\tthis._updateCursor(isAppend);\n\t\t\tthis.options.useRecycle && this._recycle(isAppend);\n\t\t\tthis._onLayoutComplete(items, isAppend, isTrusted);\n\t\t} else {\n\t\t\tvar method = isAppend ? \"append\" : \"prepend\";\n\n\t\t\tthis._renderer[method](items);\n\t\t\t// check image sizes after elements are attated on DOM\n\t\t\t_ImageLoaded2[\"default\"].check(items.map(function (item) {\n\t\t\t\treturn item.el;\n\t\t\t}), function () {\n\t\t\t\tvar layouted = _this3._layout[method](_this3._renderer.updateSize(items), _this3._items.getOutline(isAppend ? _this3._status.endCursor : _this3._status.startCursor, isAppend ? \"end\" : \"start\"));\n\n\t\t\t\t_this3._insertItems(layouted, isAppend);\n\t\t\t\t_this3._updateCursor(isAppend);\n\t\t\t\t_this3.options.useRecycle && _this3._recycle(isAppend);\n\t\t\t\t_DOMRenderer2[\"default\"].renderItems(layouted.items);\n\t\t\t\t_this3._onLayoutComplete(layouted.items, isAppend, isTrusted);\n\t\t\t});\n\t\t}\n\t};\n\n\tInfiniteGrid.prototype._isVisible = function _isVisible(index) {\n\t\tvar min = Math.min.apply(Math, this._items.getOutline(index, \"start\"));\n\t\tvar max = Math.max.apply(Math, this._items.getOutline(index, \"end\"));\n\t\tvar pos = this._watcher.getScrollPos();\n\t\tvar viewSize = this._renderer.getViewSize();\n\n\t\tif (pos + viewSize + this.options.threshold < min) {\n\t\t\treturn -1;\n\t\t} else if (pos - this.options.threshold > max) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t};\n\n\tInfiniteGrid.prototype._updateCursor = function _updateCursor(isAppend) {\n\t\tif (isAppend) {\n\t\t\tthis._status.endCursor++;\n\t\t} else if (this._status.startCursor > 0) {\n\t\t\tthis._status.startCursor--;\n\t\t} else {\n\t\t\tthis._status.endCursor++; // outside prepend\n\t\t}\n\t\tif (this._status.startCursor < 0) {\n\t\t\tthis._status.startCursor = 0;\n\t\t}\n\t};\n\n\tInfiniteGrid.prototype._insertItems = function _insertItems(layouted, isAppend) {\n\t\tlayouted.groupKey = layouted.items[0].groupKey;\n\t\tthis._items[isAppend ? \"append\" : \"prepend\"](layouted);\n\t};\n\t// called by visible\n\n\n\tInfiniteGrid.prototype._requestAppend = function _requestAppend() {\n\t\tvar items = this._getNextItems(_consts.APPEND);\n\n\t\tif (items.length) {\n\t\t\tthis._postLayout(_consts.CACHE, items, _consts.APPEND, _consts.TRUSTED);\n\t\t} else {\n\t\t\t/**\n    * This event is fired when a card element must be added at the bottom or right of a layout because there is no card to be displayed on screen when a user scrolls near bottom or right.\n    * @ko 카드 엘리먼트가 레이아웃의 아래나 오른쪽에 추가돼야 할 때 발생하는 이벤트. 사용자가 아래나 오른쪽으로 스크롤해서 화면에 표시될 카드가 없을 때 발생한다\n    * @event eg.InfiniteGrid#append\n    * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n    * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n    */\n\t\t\tthis.trigger(\"append\");\n\t\t}\n\t};\n\t// called by visible\n\n\n\tInfiniteGrid.prototype._requestPrepend = function _requestPrepend() {\n\t\tvar items = this._getNextItems(_consts.PREPEND);\n\n\t\tif (items.length) {\n\t\t\tthis._postLayout(_consts.CACHE, items, _consts.PREPEND, _consts.TRUSTED);\n\t\t} else {\n\t\t\t/**\n    * This event is fired when a card element must be added at the top or left of a layout because there is no card to be displayed on screen when a user scrolls near top or left.\n    * @ko 카드가 레이아웃의 위나 왼쪽에 추가돼야 할 때 발생하는 이벤트. 사용자가 위나 왼쪽으로 스크롤해서 화면에 표시될 카드가 없을 때 발생한다.\n    * @event eg.InfiniteGrid#prepend\n    * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n    * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n    */\n\t\t\tthis.trigger(\"prepend\");\n\t\t}\n\t};\n\n\tInfiniteGrid.prototype._onCheck = function _onCheck(_ref) {\n\t\tvar isForward = _ref.isForward,\n\t\t    scrollPos = _ref.scrollPos,\n\t\t    horizontal = _ref.horizontal,\n\t\t    orgScrollPos = _ref.orgScrollPos;\n\n\t\t/**\n   * This event is fired when the user scrolls.\n   * @ko 사용자가 스크롤 할 경우 발생하는 이벤트.\n   * @event eg.InfiniteGrid#change\n   * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n   * @param {Boolean} param.isForward Indicates whether the scroll progression direction is forward or backword. <ko>스크롤 진행방향이 앞쪽으로 진행하는 지, 뒤쪽으로 진행하는지를 나타낸다.</ko>\n   * @param {Number} param.scrollPos Current scroll position value relative to the infiniteGrid container element. <ko>infiniteGrid 컨테이너 엘리먼트 기준의 현재 스크롤 위치값</ko>\n   * @param {Boolean} param.orgScrollPos Current position of the scroll <ko>현재 스크롤 위치값</ko>\n   * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n   * @param {Boolean} options.horizontal Direction of the scroll movement (true: horizontal, false: vertical) <ko>스크롤 이동 방향 (true 가로방향, false 세로방향</ko>\n   */\n\t\tthis.trigger(\"change\", {\n\t\t\tisForward: isForward,\n\t\t\thorizontal: horizontal,\n\t\t\tscrollPos: scrollPos,\n\t\t\torgScrollPos: orgScrollPos\n\t\t});\n\t\tif (this.isProcessing()) {\n\t\t\treturn;\n\t\t}\n\t\tvar rect = this._getEdgeOffset(isForward ? \"end\" : \"start\");\n\n\t\tif (!rect) {\n\t\t\treturn;\n\t\t}\n\t\tvar targetPos = isForward ? rect[horizontal ? \"left\" : \"top\"] - this._renderer.getViewSize() : rect[horizontal ? \"right\" : \"bottom\"];\n\n\t\tif (isForward) {\n\t\t\tif (scrollPos >= targetPos) {\n\t\t\t\tthis._requestAppend();\n\t\t\t}\n\t\t} else if (scrollPos <= targetPos) {\n\t\t\tthis._fit(\"before\");\n\t\t\tthis._requestPrepend();\n\t\t}\n\t};\n\n\tInfiniteGrid.prototype._onLayoutComplete = function _onLayoutComplete(items, isAppend) {\n\t\tvar isTrusted = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n\t\tthis._updateEdge();\n\t\tthis._renderer.setContainerSize(this._getEdgeValue(\"end\"));\n\t\t!isAppend && this._fit(\"after\");\n\t\tthis._status.isProcessing = false;\n\t\t/**\n   * This event is fired when layout is successfully arranged through a call to the append(), prepend(), or layout() method.\n   * @ko 레이아웃 배치가 완료됐을 때 발생하는 이벤트. append() 메서드나 prepend() 메서드, layout() 메서드 호출 후 카드의 배치가 완료됐을 때 발생한다\n   * @event eg.InfiniteGrid#layoutComplete\n   *\n   * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n   * @param {Array} param.target Rearranged card elements<ko>재배치된 카드 엘리먼트들</ko>\n   * @param {Boolean} param.isAppend Checks whether the append() method is used to add a card element. It returns true even though the layoutComplete event is fired after the layout() method is called. <ko>카드 엘리먼트가 append() 메서드로 추가됐는지 확인한다. layout() 메서드가 호출된 후 layoutComplete 이벤트가 발생해도 'true'를 반환한다.</ko>\n   * @param {Number} param.scrollPos Current scroll position value relative to the infiniteGrid container element. <ko>infiniteGrid 컨테이너 엘리먼트 기준의 현재 스크롤 위치값</ko>\n   * @param {Boolean} param.orgScrollPos Current position of the scroll <ko>현재 스크롤 위치값</ko>\n   * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>\n   */\n\t\tthis.trigger(\"layoutComplete\", {\n\t\t\ttarget: items.concat(),\n\t\t\tisAppend: isAppend,\n\t\t\tisTrusted: isTrusted,\n\t\t\tscrollPos: this._watcher.getScrollPos(),\n\t\t\torgScrollPos: this._watcher.getOrgScrollPos()\n\t\t});\n\t\t// console.warn(\"_onLayoutComplete [\", this._status.startCursor, this._status.endCursor, \"]\");\n\t};\n\n\tInfiniteGrid.prototype._reset = function _reset() {\n\t\tthis._status = {\n\t\t\tisProcessing: false,\n\t\t\tstartCursor: -1,\n\t\t\tendCursor: -1,\n\t\t\tstart: null,\n\t\t\tend: null\n\t\t};\n\t};\n\t/**\n  * Destroys elements, properties, and events used on a grid layout.\n  * @ko 그리드 레이아웃에 사용한 엘리먼트와 속성, 이벤트를 해제한다\n  */\n\n\n\tInfiniteGrid.prototype.destroy = function destroy() {\n\t\tthis.off();\n\t\tthis._watcher.destroy();\n\t\tthis._reset();\n\t\tthis._items.clear();\n\t\tthis._renderer.destroy();\n\t};\n\n\treturn InfiniteGrid;\n}(_component2[\"default\"]);\n\nInfiniteGrid.VERSION = \"2.1.1-snapshot\";\n\nInfiniteGrid.GridLayout = _GridLayout2[\"default\"];\n\nInfiniteGrid.FrameLayout = _FrameLayout2[\"default\"];\n\nInfiniteGrid.SquareLayout = _SquareLayout2[\"default\"];\n\nInfiniteGrid.PackingLayout = _PackingLayout2[\"default\"];\n\nInfiniteGrid.JustifiedLayout = _JustifiedLayout2[\"default\"];\n\nexports[\"default\"] = InfiniteGrid;\nmodule.exports = exports[\"default\"];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/InfiniteGrid.js\n// module id = 6\n// module chunks = 0 1","module.exports = __WEBPACK_EXTERNAL_MODULE_7__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"commonjs\":\"@egjs/component\",\"commonjs2\":\"@egjs/component\",\"amd\":\"@egjs/component\",\"root\":[\"eg\",\"Component\"]}\n// module id = 7\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\n\nvar _consts = require(\"./consts\");\n\nvar _DOMRenderer = require(\"./DOMRenderer\");\n\nvar _DOMRenderer2 = _interopRequireDefault(_DOMRenderer);\n\nvar _utils = require(\"./utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ItemManager = function () {\n\tItemManager.from = function from(elements, selector, _ref) {\n\t\tvar groupKey = _ref.groupKey,\n\t\t    isAppend = _ref.isAppend;\n\n\t\tvar filted = ItemManager.selectItems((0, _utils.$)(elements, _consts.MULTI), selector);\n\n\t\t// Item Structure\n\t\treturn (0, _utils.toArray)(filted).map(function (el) {\n\t\t\treturn {\n\t\t\t\tel: el,\n\t\t\t\tgroupKey: groupKey,\n\t\t\t\tcontent: el.outerHTML\n\t\t\t};\n\t\t});\n\t};\n\n\tItemManager.selectItems = function selectItems(elements, selector) {\n\t\treturn elements.filter(function (v) {\n\t\t\tif (selector === \"*\") {\n\t\t\t\treturn v;\n\t\t\t} else {\n\t\t\t\treturn v.className.split(\" \").some(function (c) {\n\t\t\t\t\treturn c === selector;\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t};\n\n\tItemManager.pluck = function pluck(data, property) {\n\t\treturn data.reduce(function (acc, v) {\n\t\t\treturn acc.concat(v[property]);\n\t\t}, []);\n\t};\n\n\tfunction ItemManager() {\n\t\t_classCallCheck(this, ItemManager);\n\n\t\tthis.clear();\n\t}\n\n\tItemManager.prototype.getStatus = function getStatus() {\n\t\treturn {\n\t\t\t_data: this._data.map(function (data) {\n\t\t\t\tdata.items = data.items.map(function (item) {\n\t\t\t\t\tdelete item.el;\n\t\t\t\t\treturn item;\n\t\t\t\t});\n\t\t\t\treturn data;\n\t\t\t})\n\t\t};\n\t};\n\n\tItemManager.prototype.setStatus = function setStatus(status, start, end) {\n\t\tvar data = status._data;\n\n\t\tfor (var i = start; i <= end; i++) {\n\t\t\tdata[i].items = _DOMRenderer2[\"default\"].createElements(data[i].items);\n\t\t}\n\t\tthis.set(data);\n\t};\n\n\tItemManager.prototype.size = function size() {\n\t\treturn this._data.length;\n\t};\n\n\tItemManager.prototype.fit = function fit(base, isVertical) {\n\t\tif (!this._data.length) {\n\t\t\treturn;\n\t\t}\n\t\tvar property = isVertical ? \"top\" : \"left\";\n\n\t\tif (base !== 0) {\n\t\t\tthis._data = this._data.map(function (v) {\n\t\t\t\tv.items = v.items.map(function (item) {\n\t\t\t\t\titem.rect[property] -= base;\n\t\t\t\t\treturn item;\n\t\t\t\t});\n\t\t\t\tv.outlines.start = v.outlines.start.map(function (start) {\n\t\t\t\t\treturn start - base;\n\t\t\t\t});\n\t\t\t\tv.outlines.end = v.outlines.end.map(function (end) {\n\t\t\t\t\treturn end - base;\n\t\t\t\t});\n\t\t\t\treturn v;\n\t\t\t});\n\t\t}\n\t};\n\n\tItemManager.prototype.pluck = function pluck(property, start, end) {\n\t\tif (typeof start !== \"undefined\") {\n\t\t\tif (typeof end !== \"undefined\") {\n\t\t\t\treturn ItemManager.pluck(this._data.slice(start, end + 1), property);\n\t\t\t} else {\n\t\t\t\treturn ItemManager.pluck(this._data.slice(start, start + 1), property);\n\t\t\t}\n\t\t} else {\n\t\t\treturn ItemManager.pluck(this._data, property);\n\t\t}\n\t};\n\n\tItemManager.prototype.getOutline = function getOutline(index, property) {\n\t\tif (this._data.length) {\n\t\t\treturn this._data[index].outlines[property];\n\t\t} else {\n\t\t\treturn [];\n\t\t}\n\t};\n\n\tItemManager.prototype.getEdgeIndex = function getEdgeIndex(cursor, start, end) {\n\t\tvar prop = cursor === \"start\" ? \"min\" : \"max\";\n\t\tvar index = -1;\n\t\tvar targetValue = cursor === \"start\" ? Infinity : -Infinity;\n\n\t\tfor (var i = start; i <= end; i++) {\n\t\t\tvar value = Math[prop].apply(Math, this.getOutline(i, cursor));\n\n\t\t\tif (cursor === \"start\" && targetValue > value || cursor === \"end\" && targetValue < value) {\n\t\t\t\ttargetValue = value;\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t};\n\n\tItemManager.prototype.getEdge = function getEdge(cursor, start, end) {\n\t\tvar dataIdx = this.getEdgeIndex(cursor, start, end);\n\t\tvar items = this.pluck(\"items\", dataIdx);\n\n\t\tif (items.length) {\n\t\t\tvar itemIdx = this.getOutline(dataIdx, cursor + \"Index\");\n\n\t\t\treturn items.length > itemIdx ? items[itemIdx] : null;\n\t\t}\n\t\treturn null;\n\t};\n\n\tItemManager.prototype.getEdgeValue = function getEdgeValue(cursor, start, end) {\n\t\treturn Math[cursor === \"start\" ? \"min\" : \"max\"].apply(Math, this.pluck(\"outlines\", this.getEdgeIndex(cursor, start, end)).reduce(function (acc, v) {\n\t\t\treturn acc.concat(v[cursor]);\n\t\t}, []));\n\t};\n\n\tItemManager.prototype.append = function append(layouted) {\n\t\tthis._data.push(layouted);\n\t\treturn layouted.items;\n\t};\n\n\tItemManager.prototype.prepend = function prepend(layouted) {\n\t\tthis._data.unshift(layouted);\n\t\treturn layouted.items;\n\t};\n\n\tItemManager.prototype.clear = function clear() {\n\t\tthis._data = [];\n\t};\n\n\tItemManager.prototype.remove = function remove(element, start, end) {\n\t\tvar items = null;\n\t\tvar key = element.getAttribute(_consts.GROUPKEY_ATT);\n\t\tvar data = this.get(start, end).filter(function (v) {\n\t\t\treturn String(v.groupKey) === key;\n\t\t});\n\n\t\tif (!data.length) {\n\t\t\treturn items;\n\t\t}\n\t\tdata = data[0];\n\n\t\tvar len = data.items.length;\n\t\tvar idx = -1;\n\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tif (data.items[i].el === element) {\n\t\t\t\tidx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (~idx) {\n\t\t\t// remove item information\n\t\t\tdata.items.splice(idx, 1);\n\t\t\tthis.set(data, key);\n\t\t\titems = data.items;\n\t\t}\n\t\treturn items;\n\t};\n\n\tItemManager.prototype.get = function get(start, end) {\n\t\tif (typeof start !== \"undefined\") {\n\t\t\tif (typeof end !== \"undefined\") {\n\t\t\t\treturn this._data.slice(start, end + 1);\n\t\t\t} else {\n\t\t\t\treturn this._data.slice(start, start + 1);\n\t\t\t}\n\t\t} else {\n\t\t\treturn this._data.concat();\n\t\t}\n\t};\n\n\tItemManager.prototype.set = function set(data, key) {\n\t\tif (typeof key !== \"undefined\" && !Array.isArray(data)) {\n\t\t\tvar len = this._data.length;\n\t\t\tvar idx = -1;\n\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\tif (this._data[i].groupKey === key) {\n\t\t\t\t\tidx = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t~idx && (this._data[idx] = data);\n\t\t} else {\n\t\t\tthis._data = data.concat();\n\t\t}\n\t};\n\n\treturn ItemManager;\n}();\n\nexports[\"default\"] = ItemManager;\nmodule.exports = exports[\"default\"];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ItemManager.js\n// module id = 8\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\n\nvar _consts = require(\"./consts\");\n\nvar _utils = require(\"./utils\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ImageLoaded = function () {\n\tfunction ImageLoaded() {\n\t\t_classCallCheck(this, ImageLoaded);\n\t}\n\n\tImageLoaded.waitImageLoaded = function waitImageLoaded(needCheck, callback) {\n\t\tvar checkCount = needCheck.length;\n\t\tvar checkImage = function checkImage() {\n\t\t\tcheckCount--;\n\t\t\tcheckCount <= 0 && callback && callback();\n\t\t};\n\t\tvar onCheck = function onCheck(e) {\n\t\t\t(0, _utils.removeEvent)(e.target || e.srcElement, \"load\", onCheck);\n\t\t\t(0, _utils.removeEvent)(e.target || e.srcElement, \"error\", onCheck);\n\t\t\tcheckImage();\n\t\t};\n\n\t\t// workaround for IE\n\t\t_consts.IS_IE && needCheck.forEach(function (v) {\n\t\t\treturn v.setAttribute(\"src\", v.getAttribute(\"src\"));\n\t\t});\n\t\tneedCheck.forEach(function (v) {\n\t\t\tif (v.complete) {\n\t\t\t\tcheckImage();\n\t\t\t} else {\n\t\t\t\t(0, _utils.addEvent)(v, \"load\", onCheck);\n\t\t\t\t(0, _utils.addEvent)(v, \"error\", onCheck);\n\t\t\t}\n\t\t});\n\t};\n\n\tImageLoaded.checkImageLoaded = function checkImageLoaded(el) {\n\t\tif (el.tagName === \"IMG\") {\n\t\t\treturn !el.complete ? [el] : [];\n\t\t} else {\n\t\t\treturn (0, _utils.toArray)(el.querySelectorAll(\"img\")).filter(function (v) {\n\t\t\t\tif (v.nodeType && [1, 9, 11].indexOf(v.nodeType) !== -1) {\n\t\t\t\t\treturn !v.complete;\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n\n\tImageLoaded.check = function check(elements, callback) {\n\t\tvar _this = this;\n\n\t\tvar needCheck = elements.reduce(function (acc, v) {\n\t\t\treturn acc.concat(_this.checkImageLoaded(v));\n\t\t}, []);\n\n\t\tif (needCheck.length > 0) {\n\t\t\tImageLoaded.waitImageLoaded(needCheck, callback);\n\t\t} else {\n\t\t\t// convert to async\n\t\t\tsetTimeout(function () {\n\t\t\t\tcallback && callback();\n\t\t\t}, 0);\n\t\t}\n\t};\n\n\treturn ImageLoaded;\n}();\n\nexports[\"default\"] = ImageLoaded;\nmodule.exports = exports[\"default\"];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ImageLoaded.js\n// module id = 9\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _consts = require(\"./consts\");\n\nvar _utils = require(\"./utils\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Watcher = function () {\n\tfunction Watcher(renderer, callback) {\n\t\t_classCallCheck(this, Watcher);\n\n\t\t_extends(this._callback = {\n\t\t\tlayout: null,\n\t\t\tcheck: null\n\t\t}, callback);\n\t\tthis._timer = {\n\t\t\tresize: null\n\t\t\t// doubleCheck: null,\n\t\t\t// doubleCheckCount: RETRY,\n\t\t};\n\t\tthis._prevPos = -1;\n\t\tthis._renderer = renderer;\n\t\tthis._onCheck = this._onCheck.bind(this);\n\t\tthis._onResize = this._onResize.bind(this);\n\t\tthis.attachEvent();\n\t\tthis.setScrollPos();\n\t}\n\n\tWatcher.prototype.getStatus = function getStatus() {\n\t\treturn {\n\t\t\t_prevPos: this._prevPos,\n\t\t\tscrollPos: this.getOrgScrollPos()\n\t\t};\n\t};\n\n\tWatcher.prototype.setStatus = function setStatus(status) {\n\t\tvar applyScrollPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n\t\tthis._prevPos = status._prevPos;\n\t\tapplyScrollPos && this.scrollTo(status.scrollPos);\n\t};\n\n\tWatcher.prototype.scrollTo = function scrollTo(pos) {\n\t\tvar arrPos = this._renderer.options.isVertical ? [0, pos] : [pos, 0];\n\n\t\t_utils.scrollTo.apply(undefined, [this._renderer.view].concat(arrPos));\n\t};\n\n\tWatcher.prototype.getScrollPos = function getScrollPos() {\n\t\treturn this._prevPos;\n\t};\n\n\tWatcher.prototype.setScrollPos = function setScrollPos(pos) {\n\t\tvar rawPos = pos;\n\n\t\tif (typeof pos === \"undefined\") {\n\t\t\trawPos = this.getOrgScrollPos();\n\t\t}\n\t\tthis._prevPos = rawPos - this._renderer.getContainerOffset();\n\t};\n\n\tWatcher.prototype.attachEvent = function attachEvent() {\n\t\t(0, _utils.addEvent)(this._renderer.view, \"scroll\", this._onCheck);\n\t\t(0, _utils.addEvent)(window, \"resize\", this._onResize);\n\t};\n\n\tWatcher.prototype.getOrgScrollPos = function getOrgScrollPos() {\n\t\treturn (0, _utils.scroll)(this._renderer.view, this._renderer.options.isVertical);\n\t};\n\n\tWatcher.prototype._onCheck = function _onCheck() {\n\t\tvar orgScrollPos = this.getOrgScrollPos();\n\t\tvar prevPos = this.getScrollPos();\n\n\t\tthis.setScrollPos(orgScrollPos);\n\t\tvar scrollPos = this.getScrollPos();\n\n\t\tif (_consts.IS_IOS && orgScrollPos === 0 || prevPos === scrollPos) {\n\t\t\treturn;\n\t\t}\n\t\tthis._callback.check && this._callback.check({\n\t\t\tisForward: prevPos < scrollPos,\n\t\t\tscrollPos: scrollPos,\n\t\t\torgScrollPos: orgScrollPos,\n\t\t\thorizontal: !this._renderer.options.isVertical\n\t\t});\n\t};\n\n\tWatcher.prototype._onResize = function _onResize() {\n\t\tvar _this = this;\n\n\t\tif (this._timer.resize) {\n\t\t\tclearTimeout(this._timer.resize);\n\t\t}\n\t\tthis._timer.resize = setTimeout(function () {\n\t\t\t_this._renderer.isNeededResize() && _this._callback.layout && _this._callback.layout();\n\t\t\t_this._timer.resize = null;\n\t\t\t_this._prevPos = -1;\n\t\t}, 100);\n\t};\n\n\tWatcher.prototype.detachEvent = function detachEvent() {\n\t\t(0, _utils.removeEvent)(window, \"resize\", this._onResize);\n\t};\n\n\tWatcher.prototype.destroy = function destroy() {\n\t\tthis.detachEvent();\n\t\tthis._prevPos = -1;\n\t};\n\n\treturn Watcher;\n}();\n\nexports[\"default\"] = Watcher;\nmodule.exports = exports[\"default\"];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Watcher.js\n// module id = 10\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _consts = require(\"../consts\");\n\nvar _utils = require(\"../utils\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// ALIGN\nvar START = _consts.ALIGN.START,\n    CENTER = _consts.ALIGN.CENTER,\n    END = _consts.ALIGN.END,\n    JUSTIFY = _consts.ALIGN.JUSTIFY;\n\n/**\n * A module used to arrange card elements including content infinitely according to layout type. With this module, you can implement various layouts composed of different card elements whose sizes vary. It guarantees performance by maintaining the number of DOMs the module is handling under any circumstance\n * @ko GridLayout는 벽돌을 쌓아 올린 모양처럼 동일한 너비를 가진 이미지가 엇갈려 배열되는 레이아웃이다. 모든 이미지의 너비를 동일한 크기로 조정하고, 가장 높이가 낮은 열을 찾아 새로운 이미지를 삽입한다. 따라서 배치된 이미지 사이에 빈 공간이 생기지는 않지만 배치된 레이아웃의 아래쪽은 울퉁불퉁해진다.\n * @class eg.InfiniteGrid.GridLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.GridLayout module <ko>eg.InfiniteGrid.GridLayout 모듈의 옵션 객체</ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>아이템들 사이의 공간</ko>\n * @param {Boolean} [options.horizontal=\"vertical\"] Direction of the scroll movement (vertical, horizontal) <ko>스크롤 이동 방향 (vertical 세로방향, horizontal 가로방향)</ko>\n * @param {Boolean} [options.align=START] Align of the position of the items (START, CENTER, END, JUSTIFY) <ko>아이템들의 위치의 정렬 (START, CENTER, END, JUSTIFY)</ko>\n * @param {Boolean} [options.itemSize=0] Direction of the scroll movement (true: horizontal, false: vertical) <ko>스크롤 이동 방향 (true 가로방향, false 세로방향</ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\");\n\nig.setLayout(eg.InfiniteGrid.GridLayout, {\n\tmargin: 10,\n\talign: \"start\",\n\titemSize: 200\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.GridLayout({\n\tmargin: 10,\n\talign: \"center\",\n\titemSize: 200,\n\tdirection: \"horizontal\"\n});\n\n</script>\n```\n **/\n\nvar GridLayout = function () {\n\tfunction GridLayout() {\n\t\tvar options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t_classCallCheck(this, GridLayout);\n\n\t\tthis.options = (0, _utils.assignOptions)({\n\t\t\talign: START,\n\t\t\titemSize: 0\n\t\t}, options);\n\t\tthis._size = 0;\n\t\tthis._isHorizontal = this.options.direction === _consts.HORIZONTAL;\n\t\tthis._columnSize = 0;\n\t\tthis._columnLength = 0;\n\t\tthis._style = (0, _utils.getStyleNames)(this.options.direction);\n\t}\n\n\tGridLayout.prototype.getPoints = function getPoints(outlines) {\n\t\tvar pos = this._isHorizontal ? \"left\" : \"top\";\n\n\t\treturn outlines.map(function (outline) {\n\t\t\treturn outline[pos];\n\t\t});\n\t};\n\n\tGridLayout.prototype.checkColumn = function checkColumn(item) {\n\t\tvar margin = this.options.margin;\n\t\t// if direction is horizontal, fixed dimension is height\n\t\t// if direction is vertical, fixed dimension is width\n\t\tvar sizeName = this._isHorizontal ? \"height\" : \"width\";\n\t\tvar columnSize = this.options.itemSize || item && item.size[sizeName] || 0;\n\n\t\tthis._columnSize = columnSize;\n\t\tif (!columnSize) {\n\t\t\tthis._columnLength = 1;\n\t\t\treturn;\n\t\t}\n\t\tthis._columnLength = Math.max(parseInt((this._size + margin) / (columnSize + margin), 10), 1);\n\t};\n\n\tGridLayout.prototype._layout = function _layout(items, outline, isAppend) {\n\t\tvar length = items.length;\n\t\tvar margin = this.options.margin;\n\t\tvar align = this.options.align;\n\t\tvar style = this._style;\n\n\t\tvar size1Name = style.size1;\n\t\tvar size2Name = style.size2;\n\t\tvar pos1Name = style.pos1;\n\t\tvar pos2Name = style.pos2;\n\t\tvar columnSize = this._columnSize;\n\t\tvar columnLength = this._columnLength;\n\n\t\tvar size = this._size;\n\t\tvar viewDist = size - (columnSize + margin) * columnLength + margin;\n\n\t\tvar pointCaculateName = isAppend ? \"min\" : \"max\";\n\t\tvar startOutline = outline.slice();\n\t\tvar endOutline = outline.slice();\n\t\tvar startIndex = 0;\n\t\tvar endIndex = -1;\n\t\tvar endPos = -1;\n\n\t\tfor (var i = 0; i < length; ++i) {\n\t\t\tvar _item$rect;\n\n\t\t\tvar point = Math[pointCaculateName].apply(Math, endOutline) || 0;\n\t\t\tvar index = endOutline.indexOf(point);\n\t\t\tvar item = items[isAppend ? i : length - 1 - i];\n\t\t\tvar size1 = item.size[size1Name];\n\t\t\tvar size2 = item.size[size2Name];\n\t\t\tvar pos1 = isAppend ? point : point - margin - size1;\n\t\t\tvar endPos1 = pos1 + size1 + margin;\n\n\t\t\tif (index === -1) {\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\tvar pos2 = (columnSize + margin) * index;\n\n\t\t\t// ALIGN\n\t\t\tif (align === CENTER) {\n\t\t\t\tpos2 += viewDist / 2;\n\t\t\t} else if (align === END) {\n\t\t\t\tpos2 += viewDist + columnSize - size2;\n\t\t\t} else if (align === JUSTIFY) {\n\t\t\t\tpos2 = (size - columnSize) / (columnLength - 1) * index;\n\t\t\t}\n\t\t\t// tetris\n\t\t\titem.rect = (_item$rect = {}, _item$rect[pos1Name] = pos1, _item$rect[pos2Name] = pos2, _item$rect);\n\t\t\titem.column = index;\n\t\t\tendOutline[index] = isAppend ? endPos1 : pos1;\n\t\t\tif (endIndex === -1) {\n\t\t\t\tendIndex = i;\n\t\t\t\tendPos = endPos1;\n\t\t\t} else if (endPos < endPos1) {\n\t\t\t\tendIndex = i;\n\t\t\t\tendPos = endPos1;\n\t\t\t}\n\t\t}\n\t\tif (!isAppend) {\n\t\t\titems.sort(function (a, b) {\n\t\t\t\tvar item1pos1 = a.rect[pos1Name];\n\t\t\t\tvar item1pos2 = a.rect[pos2Name];\n\t\t\t\tvar item2pos1 = b.rect[pos1Name];\n\t\t\t\tvar item2pos2 = b.rect[pos2Name];\n\n\t\t\t\tif (item1pos1 - item2pos1) {\n\t\t\t\t\treturn item1pos1 - item2pos1;\n\t\t\t\t}\n\t\t\t\treturn item1pos2 - item2pos2;\n\t\t\t});\n\t\t\tendIndex = length - 1;\n\t\t}\n\t\t// if append items, startOutline is low, endOutline is high\n\t\t// if prepend items, startOutline is high, endOutline is low\n\t\treturn {\n\t\t\tstart: isAppend ? startOutline : endOutline,\n\t\t\tend: isAppend ? endOutline : startOutline,\n\t\t\tstartIndex: startIndex,\n\t\t\tendIndex: endIndex\n\t\t};\n\t};\n\n\tGridLayout.prototype._insert = function _insert() {\n\t\tvar items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\t\tvar outline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\t\tvar type = arguments[2];\n\n\t\tvar clone = items.map(function (item) {\n\t\t\treturn _extends({}, item);\n\t\t});\n\n\t\tvar startOutline = outline;\n\n\t\tif (!this._columnLength) {\n\t\t\tthis.checkColumn(items[0]);\n\t\t}\n\t\tif (outline.length !== this._columnLength) {\n\t\t\tstartOutline = (0, _utils.fill)(this._columnLength, outline.length === 0 ? 0 : Math[type === _consts.APPEND ? \"min\" : \"max\"].apply(Math, outline) || 0);\n\t\t}\n\n\t\tvar result = this._layout(clone, startOutline, type);\n\n\t\treturn {\n\t\t\titems: clone,\n\t\t\toutlines: result\n\t\t};\n\t};\n\t/**\n  * Adds items at the bottom of a outline.\n  * @ko 아이템들을 아웃라인 아래에 추가한다.\n  * @method eg.InfiniteGrid.GridLayout#append\n  * @param {Array} items Array of items to be layouted <ko>레이아웃할 아이템들의 배열</ko>\n  * @param {Array} outline Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n  * @return {Object} Layouted items and outline of start and end <ko> 레이아웃이 된 아이템과 시작과 끝의 아웃라인이 담긴 정보</ko>\n  * @example\n  * layout.prepend(items, [100, 200, 300, 400]);\n  */\n\n\n\tGridLayout.prototype.append = function append(items, outline) {\n\t\treturn this._insert(items, outline, _consts.APPEND);\n\t};\n\t/**\n  * Adds items at the top of a outline.\n  * @ko 아이템을 아웃라인 위에 추가한다.\n  * @method eg.InfiniteGrid.GridLayout#prepend\n  * @param {Array} items Array of items to be layouted <ko>레이아웃할 아이템들의 배열</ko>\n  * @param {Array} outline Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n  * @return {Object} Layouted items and outline of start and end <ko> 레이아웃이 된 아이템과 시작과 끝의 아웃라인이 담긴 정보</ko>\n  * @example\n  * layout.prepend(items, [100, 200, 300, 400]);\n  */\n\n\n\tGridLayout.prototype.prepend = function prepend(items, outline) {\n\t\treturn this._insert(items, outline, _consts.PREPEND);\n\t};\n\t/**\n  * Adds items of groups at the bottom of a outline.\n  * @ko 그룹들의 아이템들을 아웃라인 아래에 추가한다.\n  * @method eg.InfiniteGrid.GridLayout#layout\n  * @param {Array} groups Array of groups to be layouted <ko>레이아웃할 그룹들의 배열</ko>\n  * @param {Array} outline Array of outline points to be reference points <ko>기준점이 되는 아웃라인 점들의 배열</ko>\n  * @return {eg.InfiniteGrid.GridLayout} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n  * @example\n  * layout.layout(groups, [100, 200, 300, 400]);\n  */\n\n\n\tGridLayout.prototype.layout = function layout() {\n\t\tvar _this = this;\n\n\t\tvar groups = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\t\tvar outline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n\t\tvar firstItem = groups.length && groups[0].items.length && groups[0].items[0] || 0;\n\n\t\tthis.checkColumn(firstItem);\n\n\t\t// if outlines' length and columns' length are now same, re-caculate outlines.\n\t\tvar startOutline = void 0;\n\n\t\tif (outline.length !== this._columnLength) {\n\t\t\tvar pos = outline.length === 0 ? 0 : Math.min.apply(Math, outline);\n\n\t\t\t// re-layout items.\n\t\t\tstartOutline = (0, _utils.fill)(this._columnLength, pos);\n\t\t} else {\n\t\t\tstartOutline = outline.slice();\n\t\t}\n\t\tgroups.forEach(function (group) {\n\t\t\tvar items = group.items;\n\t\t\tvar result = _this._layout(items, startOutline, _consts.APPEND);\n\n\t\t\tgroup.outlines = result;\n\t\t\tstartOutline = result.end;\n\t\t});\n\n\t\treturn this;\n\t};\n\t/**\n  * Set the viewport size of the layout.\n  * @ko 레이아웃의 가시 사이즈를 설정한다.\n  * @method eg.InfiniteGrid.GridLayout#setSize\n  * @param {Number} size The viewport size of container area where items are added to a layout <ko>레이아웃에 아이템을 추가하는 컨테이너 영역의 가시 사이즈</ko>\n  * @return {eg.InfiniteGrid.GridLayout} An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n  * @example\n  * layout.layout(groups, [100, 200, 300, 400]);\n  */\n\n\n\tGridLayout.prototype.setSize = function setSize(size) {\n\t\tthis._size = size;\n\t\treturn this;\n\t};\n\n\treturn GridLayout;\n}();\n\nexports[\"default\"] = GridLayout;\nmodule.exports = exports[\"default\"];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/layouts/GridLayout.js\n// module id = 11\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\n\nvar _FrameLayout2 = require(\"./FrameLayout\");\n\nvar _FrameLayout3 = _interopRequireDefault(_FrameLayout2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction makeShapeOutline(outline, itemSize, columnLength, isAppend) {\n\tvar point = Math[isAppend ? \"min\" : \"max\"].apply(Math, outline) || 0;\n\n\tif (outline.length !== columnLength) {\n\t\treturn new Array(columnLength).fill(0);\n\t}\n\treturn outline.map(function (l) {\n\t\treturn parseInt((l - point) / itemSize, 10);\n\t});\n}\nfunction getColumn(item) {\n\tif (item.column) {\n\t\treturn item.column;\n\t}\n\tif (item.el) {\n\t\tvar dataset = item.el.dataset;\n\n\t\tif (dataset) {\n\t\t\titem.column = dataset.column || 1;\n\t\t} else {\n\t\t\titem.column = item.el.getAttribute(\"column\") || 1;\n\t\t}\n\t\treturn item.column;\n\t}\n\titem.column = 1;\n\treturn 1;\n}\n\nvar SquareLayout = function (_FrameLayout) {\n\t_inherits(SquareLayout, _FrameLayout);\n\n\tfunction SquareLayout() {\n\t\t_classCallCheck(this, SquareLayout);\n\n\t\treturn _possibleConstructorReturn(this, _FrameLayout.apply(this, arguments));\n\t}\n\n\tSquareLayout.prototype._checkItemSize = function _checkItemSize() {\n\t\tvar column = this.options.column;\n\n\t\tif (!column) {\n\t\t\t_FrameLayout.prototype._checkItemSize.call(this);\n\t\t\treturn;\n\t\t}\n\t\tvar margin = this.options.margin;\n\n\t\t// if itemSize is not in options, caculate itemSize from size.\n\t\tthis._itemSize = (this._size + margin) / column - margin;\n\t};\n\n\tSquareLayout.prototype._layout = function _layout(items) {\n\t\tvar _shapes;\n\n\t\tvar outline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\t\tvar isAppend = arguments[2];\n\n\t\tvar itemSize = this._getItemSize();\n\t\tvar margin = this.options.margin;\n\t\tvar columnLength = this.options.column || parseInt((this._size + margin) / (itemSize + margin), 10);\n\t\tvar length = items.length;\n\t\tvar endOutline = makeShapeOutline(outline, itemSize, columnLength, isAppend);\n\t\tvar pointCaculateName = isAppend ? \"min\" : \"max\";\n\t\tvar shapes = [];\n\t\tvar sign = isAppend ? 1 : -1;\n\t\tvar style = this._style;\n\t\tvar pos1Name = style.pos1;\n\t\tvar pos2Name = style.pos2;\n\n\t\tfor (var i = 0; i < length; ++i) {\n\t\t\tvar _shapes$push;\n\n\t\t\tvar point = Math[pointCaculateName].apply(Math, endOutline);\n\t\t\tvar index = endOutline.indexOf(point);\n\t\t\tvar item = items[isAppend ? i : length - 1 - i];\n\t\t\tvar column = getColumn(item);\n\t\t\tvar columnCount = 1;\n\n\t\t\tif (column > 1) {\n\t\t\t\tfor (var j = 1; j < column && index + j < columnLength; ++j) {\n\t\t\t\t\tif (isAppend && endOutline[index + j] <= point || !isAppend && endOutline[index + j] >= point) {\n\t\t\t\t\t\t++columnCount;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshapes.push((_shapes$push = {\n\t\t\t\twidth: columnCount,\n\t\t\t\theight: columnCount\n\t\t\t}, _shapes$push[pos1Name] = point - (!isAppend ? columnCount : 0), _shapes$push[pos2Name] = index, _shapes$push));\n\t\t\tfor (var _j = 0; _j < columnCount; ++_j) {\n\t\t\t\tendOutline[index + _j] = point + sign * columnCount;\n\t\t\t}\n\t\t}\n\n\t\tthis._shapes = (_shapes = {\n\t\t\tshapes: shapes\n\t\t}, _shapes[style.size2] = columnLength, _shapes);\n\t\tvar result = _FrameLayout.prototype._layout.call(this, items, outline, isAppend);\n\n\t\tshapes.sort(function (shape1, shape2) {\n\t\t\tvar item1pos1 = shape1[pos1Name];\n\t\t\tvar item1pos2 = shape1[pos2Name];\n\t\t\tvar item2pos1 = shape2[pos1Name];\n\t\t\tvar item2pos2 = shape2[pos2Name];\n\n\t\t\tif (item1pos1 - item2pos1) {\n\t\t\t\treturn item1pos1 - item2pos1;\n\t\t\t}\n\t\t\treturn item1pos2 - item2pos2;\n\t\t});\n\t\titems.sort(function (a, b) {\n\t\t\tvar item1pos1 = a.rect[pos1Name];\n\t\t\tvar item1pos2 = a.rect[pos2Name];\n\t\t\tvar item2pos1 = b.rect[pos1Name];\n\t\t\tvar item2pos2 = b.rect[pos2Name];\n\n\t\t\tif (item1pos1 - item2pos1) {\n\t\t\t\treturn item1pos1 - item2pos1;\n\t\t\t}\n\t\t\treturn item1pos2 - item2pos2;\n\t\t});\n\t\treturn result;\n\t};\n\n\treturn SquareLayout;\n}(_FrameLayout3[\"default\"]);\n\nexports[\"default\"] = SquareLayout;\nmodule.exports = exports[\"default\"];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/layouts/SquareLayout.js\n// module id = 12\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _BoxModel = require(\"./lib/BoxModel.js\");\n\nvar _BoxModel2 = _interopRequireDefault(_BoxModel);\n\nvar _consts = require(\"../consts\");\n\nvar _utils = require(\"../utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction getCost(originLength, length) {\n\tvar cost = originLength / length;\n\n\tif (cost < 1) {\n\t\tcost = 1 / cost;\n\t}\n\n\treturn cost - 1;\n}\nfunction fitArea(item, bestFitArea, itemFitSize, containerFitSize, layoutVertical) {\n\titem.height = itemFitSize.height;\n\titem.width = itemFitSize.width;\n\n\tbestFitArea.height = containerFitSize.height;\n\tbestFitArea.width = containerFitSize.width;\n\n\tif (layoutVertical) {\n\t\titem.top = bestFitArea.top + bestFitArea.height;\n\t\titem.left = bestFitArea.left;\n\t} else {\n\t\titem.left = bestFitArea.left + bestFitArea.width;\n\t\titem.top = bestFitArea.top;\n\t}\n}\n\nvar PackingLayout = function () {\n\tfunction PackingLayout() {\n\t\tvar options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t_classCallCheck(this, PackingLayout);\n\n\t\tthis.options = (0, _utils.assignOptions)({\n\t\t\taspectRatio: 1,\n\t\t\tsizeWeight: 1,\n\t\t\tratioWeight: 1\n\t\t}, options);\n\t\tthis._size = 0;\n\t\tthis._style = (0, _utils.getStyleNames)(this.options.direction);\n\t\tthis._isHorizontal = this.options.direction === _consts.HORIZONTAL;\n\t}\n\n\tPackingLayout.prototype._findBestFitArea = function _findBestFitArea(container, item) {\n\t\tif (container.getRatio() === 0) {\n\t\t\t// 아이템 최초 삽입시 전체영역 지정\n\t\t\tcontainer.originWidth = item.width;\n\t\t\tcontainer.originHeight = item.height;\n\t\t\tcontainer.width = item.width;\n\t\t\tcontainer.height = item.height;\n\t\t\treturn;\n\t\t}\n\n\t\tvar bestFitArea = null;\n\t\tvar minCost = 10000000;\n\t\tvar layoutVertical = false;\n\t\tvar itemFitSize = {\n\t\t\twidth: 0,\n\t\t\theight: 0\n\t\t};\n\t\tvar containerFitSize = {\n\t\t\twidth: 0,\n\t\t\theight: 0\n\t\t};\n\t\tvar _options = this.options,\n\t\t    sizeWeight = _options.sizeWeight,\n\t\t    ratioWeight = _options.ratioWeight;\n\n\n\t\tcontainer.innerItem.forEach(function (v) {\n\t\t\tvar containerSizeCost = getCost(v.getOriginSize(), v.getSize()) * sizeWeight;\n\t\t\tvar containerRatioCost = getCost(v.getOriginRatio(), v.getRatio()) * ratioWeight;\n\t\t\tvar cost = void 0;\n\n\t\t\tfor (var i = 0; i < 2; ++i) {\n\t\t\t\tvar itemWidth = void 0;\n\t\t\t\tvar itemHeight = void 0;\n\t\t\t\tvar containerWidth = void 0;\n\t\t\t\tvar containerHeight = void 0;\n\n\t\t\t\tif (i === 0) {\n\t\t\t\t\t// 상하에 아이템 추가\n\t\t\t\t\titemWidth = v.width;\n\t\t\t\t\titemHeight = v.height * (item.height / (v.originHeight + item.height));\n\t\t\t\t\tcontainerWidth = v.width;\n\t\t\t\t\tcontainerHeight = v.height - itemHeight;\n\t\t\t\t} else {\n\t\t\t\t\t// 좌우에 아이템 추가\n\t\t\t\t\titemHeight = v.height;\n\t\t\t\t\titemWidth = v.width * (item.width / (v.originWidth + item.width));\n\t\t\t\t\tcontainerHeight = v.height;\n\t\t\t\t\tcontainerWidth = v.width - itemWidth;\n\t\t\t\t}\n\n\t\t\t\tvar itemSize = itemWidth * itemHeight;\n\t\t\t\tvar itemRatio = itemWidth / itemHeight;\n\t\t\t\tvar containerSize = containerWidth * containerHeight;\n\t\t\t\tvar containerRatio = containerHeight / containerHeight;\n\n\t\t\t\tcost = getCost(item.getSize(), itemSize) * sizeWeight;\n\t\t\t\tcost += getCost(item.getRatio(), itemRatio) * ratioWeight;\n\t\t\t\tcost += getCost(v.getOriginSize(), containerSize) * sizeWeight - containerSizeCost;\n\t\t\t\tcost += getCost(v.getOriginRatio(), containerRatio) * ratioWeight - containerRatioCost;\n\n\t\t\t\tif (cost === Math.min(cost, minCost)) {\n\t\t\t\t\tminCost = cost;\n\t\t\t\t\tbestFitArea = v;\n\t\t\t\t\tlayoutVertical = i === 0;\n\t\t\t\t\titemFitSize.width = itemWidth;\n\t\t\t\t\titemFitSize.height = itemHeight;\n\t\t\t\t\tcontainerFitSize.width = containerWidth;\n\t\t\t\t\tcontainerFitSize.height = containerHeight;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tfitArea(item, bestFitArea, itemFitSize, containerFitSize, layoutVertical);\n\t};\n\n\tPackingLayout.prototype._layout = function _layout(items) {\n\t\tvar _this = this;\n\n\t\tvar outline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\t\tvar isAppend = arguments[2];\n\n\t\tvar style = this._style;\n\t\tvar isHorizontal = this._isHorizontal;\n\t\tvar aspectRatio = this.options.aspectRatio;\n\t\tvar margin = this.options.margin;\n\t\tvar pos1Name = style.pos1;\n\t\tvar size1Name = style.size1;\n\t\tvar containerWidth = this._size * (isHorizontal ? aspectRatio : 1);\n\t\tvar containerHeight = this._size / (isHorizontal ? 1 : aspectRatio);\n\t\tvar containerSize1 = isHorizontal ? containerWidth : containerHeight;\n\t\tvar prevOutline = (0, _utils.toZeroArray)(outline);\n\t\tvar start = isAppend ? Math.max.apply(Math, prevOutline) : Math.min.apply(Math, prevOutline) - containerSize1 - margin;\n\t\tvar end = start + containerSize1 + margin;\n\t\tvar container = new _BoxModel2[\"default\"]({});\n\n\t\tvar startIndex = -1;\n\t\tvar endIndex = -1;\n\t\tvar startPos = -1;\n\t\tvar endPos = -1;\n\n\t\titems.forEach(function (item) {\n\t\t\tvar model = new _BoxModel2[\"default\"]({\n\t\t\t\toriginWidth: item.size.width,\n\t\t\t\toriginHeight: item.size.height,\n\t\t\t\twidth: item.size.width,\n\t\t\t\theight: item.size.height\n\t\t\t});\n\n\t\t\t_this._findBestFitArea(container, model);\n\t\t\tcontainer.pushItem(model);\n\t\t\tcontainer.scaleTo(containerWidth + margin, containerHeight + margin);\n\t\t});\n\t\titems.forEach(function (item, i) {\n\t\t\tvar _container$innerItem$ = container.innerItem[i],\n\t\t\t    left = _container$innerItem$.left,\n\t\t\t    top = _container$innerItem$.top,\n\t\t\t    width = _container$innerItem$.width,\n\t\t\t    height = _container$innerItem$.height;\n\n\n\t\t\titem.rect = { top: top, left: left, width: width - margin, height: height - margin };\n\t\t\titem.rect[pos1Name] += start;\n\n\t\t\tif (startIndex === -1) {\n\t\t\t\tstartIndex = i;\n\t\t\t\tendIndex = i;\n\t\t\t\tstartPos = item.rect[pos1Name];\n\t\t\t\tendPos = startPos;\n\t\t\t}\n\t\t\tif (startPos > item.rect[pos1Name]) {\n\t\t\t\tstartPos = item.rect[pos1Name];\n\t\t\t\tstartIndex = i;\n\t\t\t}\n\t\t\tif (endPos < item.rect[pos1Name] + item.rect[size1Name] + margin) {\n\t\t\t\tendPos = item.rect[pos1Name] + item.rect[size1Name] + margin;\n\t\t\t\tendIndex = i;\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tstart: [start],\n\t\t\tend: [end],\n\t\t\tstartIndex: startIndex,\n\t\t\tendIndex: endIndex\n\t\t};\n\t};\n\n\tPackingLayout.prototype._insert = function _insert(items, outline, type) {\n\t\t// this only needs the size of the item.\n\t\tvar clone = items.map(function (item) {\n\t\t\treturn _extends({}, item);\n\t\t});\n\n\t\treturn {\n\t\t\titems: clone,\n\t\t\toutlines: this._layout(clone, outline, type)\n\t\t};\n\t};\n\n\tPackingLayout.prototype.append = function append(items, outline) {\n\t\treturn this._insert(items, outline, _consts.APPEND);\n\t};\n\n\tPackingLayout.prototype.prepend = function prepend(items, outline) {\n\t\treturn this._insert(items, outline, _consts.PREPEND);\n\t};\n\n\tPackingLayout.prototype.layout = function layout(groups) {\n\t\tvar outline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n\t\tvar length = groups.length;\n\t\tvar point = outline;\n\n\t\tfor (var i = 0; i < length; ++i) {\n\t\t\tvar group = groups[i];\n\n\t\t\tpoint = this._layout(group.items, point, _consts.APPEND);\n\t\t\tgroup.outlines = point;\n\t\t\tpoint = point.end;\n\t\t}\n\t};\n\n\tPackingLayout.prototype.setSize = function setSize(size) {\n\t\tthis._size = size;\n\t};\n\n\treturn PackingLayout;\n}();\n\nexports[\"default\"] = PackingLayout;\nmodule.exports = exports[\"default\"];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/layouts/PackingLayout.js\n// module id = 13\n// module chunks = 0 1","\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar BoxModel = function () {\n\tfunction BoxModel(option) {\n\t\t_classCallCheck(this, BoxModel);\n\n\t\tthis._originWidth = option.originWidth || 0;\n\t\tthis._originHeight = option.originHeight || 0;\n\t\tthis._width = option.width || 0;\n\t\tthis._height = option.height || 0;\n\t\tthis._left = option.left || 0;\n\t\tthis._top = option.top || 0;\n\t\tthis._item = option.item;\n\t\tthis._innerItem = option.innerItem || [];\n\t}\n\n\tBoxModel.prototype.scaleTo = function scaleTo(width, height) {\n\t\tvar scaleX = this._width === 0 ? 0 : width / this._width;\n\t\tvar scaleY = this._height === 0 ? 0 : height / this._height;\n\n\t\tthis._innerItem.forEach(function (v) {\n\t\t\tif (scaleX !== 0) {\n\t\t\t\tv.left *= scaleX;\n\t\t\t\tv.width *= scaleX;\n\t\t\t}\n\t\t\tif (scaleY !== 0) {\n\t\t\t\tv.top *= scaleY;\n\t\t\t\tv.height *= scaleY;\n\t\t\t}\n\t\t});\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t};\n\n\tBoxModel.prototype.pushItem = function pushItem(item) {\n\t\tthis._innerItem.push(item);\n\t};\n\n\tBoxModel.prototype.getOriginSize = function getOriginSize() {\n\t\treturn this.originWidth * this.originHeight;\n\t};\n\n\tBoxModel.prototype.getSize = function getSize() {\n\t\treturn this.width * this.height;\n\t};\n\n\tBoxModel.prototype.getOriginRatio = function getOriginRatio() {\n\t\treturn this.originHeight === 0 ? 0 : this.originWidth / this.originHeight;\n\t};\n\n\tBoxModel.prototype.getRatio = function getRatio() {\n\t\treturn this.height === 0 ? 0 : this.width / this.height;\n\t};\n\n\tBoxModel.prototype.isSmallerThen = function isSmallerThen(box) {\n\t\treturn this.width <= box.width && this.height <= box.height;\n\t};\n\n\tBoxModel.prototype.isEqual = function isEqual(box) {\n\t\treturn this.left === box.left && this.top === box.top && this.width === box.width && this.height === box.height;\n\t};\n\n\t_createClass(BoxModel, [{\n\t\tkey: \"item\",\n\t\tget: function get() {\n\t\t\treturn this._item;\n\t\t}\n\t}, {\n\t\tkey: \"originWidth\",\n\t\tget: function get() {\n\t\t\treturn this._originWidth;\n\t\t},\n\t\tset: function set(width) {\n\t\t\tthis._originWidth = width;\n\t\t}\n\t}, {\n\t\tkey: \"originHeight\",\n\t\tget: function get() {\n\t\t\treturn this._originHeight;\n\t\t},\n\t\tset: function set(height) {\n\t\t\tthis._originHeight = height;\n\t\t}\n\t}, {\n\t\tkey: \"width\",\n\t\tget: function get() {\n\t\t\treturn this._width;\n\t\t},\n\t\tset: function set(width) {\n\t\t\tthis._width = width;\n\t\t}\n\t}, {\n\t\tkey: \"height\",\n\t\tget: function get() {\n\t\t\treturn this._height;\n\t\t},\n\t\tset: function set(height) {\n\t\t\tthis._height = height;\n\t\t}\n\t}, {\n\t\tkey: \"left\",\n\t\tget: function get() {\n\t\t\treturn this._left;\n\t\t},\n\t\tset: function set(left) {\n\t\t\tthis._left = left;\n\t\t}\n\t}, {\n\t\tkey: \"top\",\n\t\tget: function get() {\n\t\t\treturn this._top;\n\t\t},\n\t\tset: function set(top) {\n\t\t\tthis._top = top;\n\t\t}\n\t}, {\n\t\tkey: \"innerItem\",\n\t\tget: function get() {\n\t\t\treturn this._innerItem;\n\t\t}\n\t}]);\n\n\treturn BoxModel;\n}();\n\nmodule.exports = BoxModel;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/layouts/lib/BoxModel.js\n// module id = 14\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _dijkstra = require(\"./lib/dijkstra\");\n\nvar _dijkstra2 = _interopRequireDefault(_dijkstra);\n\nvar _consts = require(\"../consts\");\n\nvar _utils = require(\"../utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar JustifiedLayout = function () {\n\tfunction JustifiedLayout() {\n\t\tvar options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t_classCallCheck(this, JustifiedLayout);\n\n\t\tthis.options = (0, _utils.assignOptions)({\n\t\t\tminSize: 0,\n\t\t\tmaxSize: 0\n\t\t}, options);\n\t\tthis._style = (0, _utils.getStyleNames)(this.options.direction);\n\t\tthis._size = 0;\n\t}\n\n\tJustifiedLayout.prototype._layout = function _layout(items, outline, isAppend) {\n\t\tvar _this = this;\n\n\t\tvar style = this._style;\n\t\tvar size1Name = style.size1;\n\t\tvar size2Name = style.size2;\n\t\tvar startIndex = 0;\n\t\tvar endIndex = items.length;\n\t\tvar graph = function graph(_start) {\n\t\t\tvar results = {};\n\t\t\tvar start = +_start.replace(/[^0-9]/g, \"\");\n\t\t\tvar length = endIndex + 1;\n\n\t\t\tfor (var i = start + 1; i < length; ++i) {\n\t\t\t\tif (i - start > 8) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tvar cost = _this._getCost(items, start, i, size1Name, size2Name);\n\n\t\t\t\tif (cost < 0 && i === length - 1) {\n\t\t\t\t\tcost = 0;\n\t\t\t\t}\n\t\t\t\tif (cost !== null) {\n\t\t\t\t\tresults[\"node\" + i] = Math.pow(cost, 2);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn results;\n\t\t};\n\t\t// shortest path for items' total height.\n\t\tvar path = _dijkstra2[\"default\"].find_path(graph, \"node\" + startIndex, \"node\" + endIndex);\n\n\t\treturn this._setStyle(items, path, outline, isAppend);\n\t};\n\n\tJustifiedLayout.prototype._getSize = function _getSize(items, size1Name, size2Name) {\n\t\tvar margin = this.options.margin;\n\t\tvar size = items.reduce(function (sum, item) {\n\t\t\treturn sum + item.size[size2Name] / item.size[size1Name];\n\t\t}, 0);\n\n\t\treturn (this._size - margin * (items.length - 1)) / size;\n\t};\n\n\tJustifiedLayout.prototype._getCost = function _getCost(items, i, j, size1Name, size2Name) {\n\t\tvar size = this._getSize(items.slice(i, j), size1Name, size2Name);\n\t\tvar min = this.options.minSize || 0;\n\t\tvar max = this.options.maxSize || Infinity;\n\n\t\tif (isFinite(max)) {\n\t\t\t// if this size is not in range, the cost increases sharply.\n\t\t\tif (size < min) {\n\t\t\t\treturn Math.pow(size - min, 2) + Math.pow(max, 2);\n\t\t\t} else if (size > max) {\n\t\t\t\treturn Math.pow(size - max, 2) + Math.pow(max, 2);\n\t\t\t} else {\n\t\t\t\t// if this size in range, the cost is negative or low.\n\t\t\t\treturn Math.min(size - max, min - size);\n\t\t\t}\n\t\t}\n\t\t// if max is infinite type, caculate cost only with \"min\".\n\t\tif (size < min) {\n\t\t\treturn Math.max(Math.pow(min, 2), Math.pow(size, 2));\n\t\t}\n\t\treturn size - min;\n\t};\n\n\tJustifiedLayout.prototype._setStyle = function _setStyle(items, path) {\n\t\tvar outline = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\t\tvar isAppend = arguments[3];\n\n\t\tvar style = this._style;\n\t\t// if direction is vertical\n\t\t// pos1 : top, pos11 : bottom\n\t\t// size1 : height\n\t\t// pos2 : left, pos22 : right\n\t\t// size2 : width\n\n\t\t// if direction is horizontal\n\t\t// pos1 : left, pos11 : right\n\t\t// size1 : width\n\t\t// pos2 : top, pos22 : bottom\n\t\t// size2 : height\n\t\tvar pos1Name = style.pos1;\n\t\tvar size1Name = style.size1;\n\t\tvar pos2Name = style.pos2;\n\t\tvar size2Name = style.size2;\n\t\tvar length = path.length;\n\t\tvar margin = this.options.margin;\n\t\tvar startPoint = outline[0] || 0;\n\t\tvar endPoint = startPoint;\n\t\tvar height = 0;\n\n\t\tfor (var i = 0; i < length - 1; ++i) {\n\t\t\tvar path1 = parseInt(path[i].replace(\"node\", \"\"), 10);\n\t\t\tvar path2 = parseInt(path[i + 1].replace(\"node\", \"\"), 10);\n\t\t\t// pathItems(path1 to path2) are in 1 line.\n\t\t\tvar pathItems = items.slice(path1, path2);\n\t\t\tvar pathItemsLength = pathItems.length;\n\t\t\tvar size1 = this._getSize(pathItems, size1Name, size2Name);\n\t\t\tvar pos1 = endPoint;\n\n\t\t\tfor (var j = 0; j < pathItemsLength; ++j) {\n\t\t\t\tvar _item$rect;\n\n\t\t\t\tvar item = pathItems[j];\n\t\t\t\tvar size2 = item.size[size2Name] / item.size[size1Name] * size1;\n\t\t\t\t// item has margin bottom and right.\n\t\t\t\t// first item has not margin.\n\t\t\t\tvar prevItemRect = j === 0 ? 0 : pathItems[j - 1].rect;\n\t\t\t\tvar pos2 = prevItemRect ? prevItemRect[pos2Name] + prevItemRect[size2Name] + margin : 0;\n\n\t\t\t\titem.rect = (_item$rect = {}, _item$rect[pos1Name] = pos1, _item$rect[pos2Name] = pos2, _item$rect[size1Name] = size1, _item$rect[size2Name] = size2, _item$rect);\n\t\t\t}\n\t\t\theight += margin + size1;\n\t\t\tendPoint = startPoint + height;\n\t\t}\n\t\tvar itemsLength = items.length;\n\t\tvar startIndex = itemsLength ? 0 : -1;\n\t\tvar endIndex = itemsLength ? itemsLength - 1 : -1;\n\n\t\tif (isAppend) {\n\t\t\t// previous group's end outline is current group's start outline\n\t\t\treturn {\n\t\t\t\tstart: [startPoint],\n\t\t\t\tend: [endPoint],\n\t\t\t\tstartIndex: startIndex,\n\t\t\t\tendIndex: endIndex\n\t\t\t};\n\t\t}\n\t\t// for prepend, only substract height from position.\n\t\t// always start is lower than end.\n\n\t\tfor (var _i = 0; _i < itemsLength; ++_i) {\n\t\t\tvar _item = items[_i];\n\n\t\t\t// move items as long as height for prepend\n\t\t\t_item.rect[pos1Name] -= height;\n\t\t}\n\t\treturn {\n\t\t\tstart: [startPoint - height],\n\t\t\tend: [startPoint], // endPoint - height = startPoint\n\t\t\tstartIndex: startIndex,\n\t\t\tendIndex: endIndex\n\t\t};\n\t};\n\n\tJustifiedLayout.prototype._insert = function _insert(items, outline, type) {\n\t\t// this only needs the size of the item.\n\t\tvar clone = items.map(function (item) {\n\t\t\treturn _extends({}, item);\n\t\t});\n\n\t\treturn {\n\t\t\titems: clone,\n\t\t\toutlines: this._layout(clone, outline, type)\n\t\t};\n\t};\n\n\tJustifiedLayout.prototype.setSize = function setSize(size) {\n\t\tthis._size = size;\n\t};\n\n\tJustifiedLayout.prototype.append = function append(items, outline) {\n\t\treturn this._insert(items, outline, _consts.APPEND);\n\t};\n\n\tJustifiedLayout.prototype.prepend = function prepend(items, outline) {\n\t\treturn this._insert(items, outline, _consts.PREPEND);\n\t};\n\n\tJustifiedLayout.prototype.layout = function layout(groups, outlines) {\n\t\tvar length = groups.length;\n\t\tvar point = outlines;\n\n\t\tfor (var i = 0; i < length; ++i) {\n\t\t\tvar group = groups[i];\n\n\t\t\tpoint = this._layout(group.items, point, _consts.APPEND);\n\t\t\tgroup.outlines = point;\n\t\t\tpoint = point.end;\n\t\t}\n\t};\n\n\treturn JustifiedLayout;\n}();\n\nexports[\"default\"] = JustifiedLayout;\nmodule.exports = exports[\"default\"];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/layouts/JustifiedLayout.js\n// module id = 15\n// module chunks = 0 1","'use strict';\n\n/* eslint-disable */\n/******************************************************************************\n * Created 2008-08-19.\n *\n * Dijkstra path-finding functions. Adapted from the Dijkstar Python project.\n *\n * Copyright (C) 2008\n *   Wyatt Baldwin <self@wyattbaldwin.com>\n *   All rights reserved\n *\n * Licensed under the MIT license.\n *\n *   http://www.opensource.org/licenses/mit-license.php\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *****************************************************************************/\n(function () {\n  var dijkstra = {\n    single_source_shortest_paths: function single_source_shortest_paths(graph, s, d) {\n      // Predecessor map for each node that has been encountered.\n      // node ID => predecessor node ID\n      var predecessors = {};\n\n      // Costs of shortest paths from s to all nodes encountered.\n      // node ID => cost\n      var costs = {};\n      costs[s] = 0;\n\n      // Costs of shortest paths from s to all nodes encountered; differs from\n      // `costs` in that it provides easy access to the node that currently has\n      // the known shortest path from s.\n      // XXX: Do we actually need both `costs` and `open`?\n      var open = new BinaryHeap(function (x) {\n        return x.cost;\n      });\n      open.push({ value: s, cost: 0 });\n\n      var closest, u, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;\n      while (open.size()) {\n        // In the nodes remaining in graph that have a known cost from s,\n        // find the node, u, that currently has the shortest path from s.\n        closest = open.pop();\n        u = closest.value;\n        cost_of_s_to_u = closest.cost;\n\n        // Get nodes adjacent to u...\n        adjacent_nodes = graph(u) || {};\n\n        // ...and explore the edges that connect u to those nodes, updating\n        // the cost of the shortest paths to any or all of those nodes as\n        // necessary. v is the node across the current edge from u.\n        for (var v in adjacent_nodes) {\n          // Get the cost of the edge running from u to v.\n          cost_of_e = adjacent_nodes[v];\n\n          // Cost of s to u plus the cost of u to v across e--this is *a*\n          // cost from s to v that may or may not be less than the current\n          // known cost to v.\n          cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;\n\n          // If we haven't visited v yet OR if the current known cost from s to\n          // v is greater than the new cost we just found (cost of s to u plus\n          // cost of u to v across e), update v's cost in the cost list and\n          // update v's predecessor in the predecessor list (it's now u).\n          cost_of_s_to_v = costs[v];\n          first_visit = typeof costs[v] === 'undefined';\n          if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {\n            costs[v] = cost_of_s_to_u_plus_cost_of_e;\n            open.push({ value: v, cost: cost_of_s_to_u_plus_cost_of_e });\n            predecessors[v] = u;\n          }\n        }\n      }\n\n      if (typeof costs[d] === 'undefined') {\n        var msg = ['Could not find a path from ', s, ' to ', d, '.'].join('');\n        throw new Error(msg);\n      }\n\n      return predecessors;\n    },\n\n    extract_shortest_path_from_predecessor_list: function extract_shortest_path_from_predecessor_list(predecessors, d) {\n      var nodes = [];\n      var u = d;\n      var predecessor;\n      while (u) {\n        nodes.push(u);\n        predecessor = predecessors[u];\n        u = predecessors[u];\n      }\n      nodes.reverse();\n      return nodes;\n    },\n\n    find_path: function find_path(graph, s, d) {\n      var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);\n      return dijkstra.extract_shortest_path_from_predecessor_list(predecessors, d);\n    }\n\n  };\n\n  function BinaryHeap(scoreFunction) {\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n  }\n\n  BinaryHeap.prototype = {\n    push: function push(element) {\n      // Add the new element to the end of the array.\n      this.content.push(element);\n      // Allow it to bubble up.\n      this.bubbleUp(this.content.length - 1);\n    },\n\n    pop: function pop() {\n      // Store the first element so we can return it later.\n      var result = this.content[0];\n      // Get the element at the end of the array.\n      var end = this.content.pop();\n      // If there are any elements left, put the end element at the\n      // start, and let it sink down.\n      if (this.content.length > 0) {\n        this.content[0] = end;\n        this.sinkDown(0);\n      }\n      return result;\n    },\n\n    remove: function remove(node) {\n      var len = this.content.length;\n      // To remove a value, we must search through the array to find\n      // it.\n      for (var i = 0; i < len; i++) {\n        if (this.content[i] === node) {\n          // When it is found, the process seen in 'pop' is repeated\n          // to fill up the hole.\n          var end = this.content.pop();\n          if (i !== len - 1) {\n            this.content[i] = end;\n            if (this.scoreFunction(end) < this.scoreFunction(node)) {\n              this.bubbleUp(i);\n            } else {\n              this.sinkDown(i);\n            }\n          }\n          return;\n        }\n      }\n      throw new Error('Node not found.');\n    },\n\n    size: function size() {\n      return this.content.length;\n    },\n\n    bubbleUp: function bubbleUp(n) {\n      // Fetch the element that has to be moved.\n      var element = this.content[n];\n      // When at 0, an element can not go up any further.\n      while (n > 0) {\n        // Compute the parent element's index, and fetch it.\n        var parentN = Math.floor((n + 1) / 2) - 1,\n            parent = this.content[parentN];\n        // Swap the elements if the parent is greater.\n        if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n          this.content[parentN] = element;\n          this.content[n] = parent;\n          // Update 'n' to continue at the new position.\n          n = parentN;\n        }\n        // Found a parent that is less, no need to move it further.\n        else {\n            break;\n          }\n      }\n    },\n\n    sinkDown: function sinkDown(n) {\n      // Look up the target element and its score.\n      var length = this.content.length,\n          element = this.content[n],\n          elemScore = this.scoreFunction(element);\n\n      while (true) {\n        // Compute the indices of the child elements.\n        var child2N = (n + 1) * 2,\n            child1N = child2N - 1;\n        // This is used to store the new position of the element,\n        // if any.\n        var swap = null;\n        // If the first child exists (is inside the array)...\n        if (child1N < length) {\n          // Look it up and compute its score.\n          var child1 = this.content[child1N],\n              child1Score = this.scoreFunction(child1);\n          // If the score is less than our element's, we need to swap.\n          if (child1Score < elemScore) {\n            swap = child1N;\n          }\n        }\n        // Do the same checks for the other child.\n        if (child2N < length) {\n          var child2 = this.content[child2N],\n              child2Score = this.scoreFunction(child2);\n          if (child2Score < (swap == null ? elemScore : child1Score)) {\n            swap = child2N;\n          }\n        }\n\n        // If the element needs to be moved, swap it, and continue.\n        if (swap !== null) {\n          this.content[n] = this.content[swap];\n          this.content[swap] = element;\n          n = swap;\n        }\n        // Otherwise, we are done.\n        else {\n            break;\n          }\n      }\n    }\n  };\n\n  /**\n   * Browserify 지원을 위한 모듈화 코드\n   */\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = dijkstra;\n  } else {\n    window.dijkstra = dijkstra;\n  }\n})();\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/layouts/lib/dijkstra.js\n// module id = 16\n// module chunks = 0 1"],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC5MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC/TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AC1uBA;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC5OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC5NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}